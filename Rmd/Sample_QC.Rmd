---
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: spacelab # flatly spacelab sandstone cerulean
    code_download: true
title: "Study-wide sample quality control"
subtitle: "Study name"
author: "Matthew J. Meier"
---

Modified from code provided by Andrew Williams (Health Canada) and recommendations from Joshua Harrill (US EPA).  

This should be run prior to DEG/BMD analysis to remove any suspect samples from across the entire study.  

The metadata you use should have the following columns with T or F listed for each sample:  

* `technical_control`  
* `reference_rna`  
* `solvent_control`  

```{r parameters}
############################################################################
# Parameters (cutoffs)
############################################################################
clust_method="spearman" # For clustering
tree_height_cutoff=0.1 # For clustering
dendo_color_by="chemical" # Specify how you would like to color the dendograms
nmr_threshold=100000 # 10% of 1M reads for TempOSeq = 100,000; 10% of 10M reads for RNA-Seq = 1,000,000.
sampledata_sep="," # Comma for TempO-Seq, Maybe tabs for RNASeq, customize!
groups=c("group","sex","pool") # Column name(s) in your metadata to use for annotations of experimental groups
# Column names for metadata, if applicable
technical_control="technical_control"
reference_rna="reference_rna"
solvent_control="solvent_control"
```

```{r load_libraries, message=F, warnings=F, echo=F}
############################################################################
# Libraries
############################################################################
library(edgeR)
library(cluster)
library(Cairo)
library(sfsmisc)
library(fields)
library(heatmap3)
library(DESeq2)
library(tidyverse)
library(foreach)
library(doParallel)
library(UpSetR)
library(GGally)
library(pheatmap)
library(ComplexHeatmap)
library(kableExtra)
library(dendextend)
library(dendsort)
library(vtree) # Richard Webster and Nick Barrowman
```

```{r paths}
############################################################################
# File paths in project directory
############################################################################
paths <- list()
paths$root <- here::here()
paths$data <- paste0(paths$root, "/data")
paths$output <- paste0(paths$data, "/output")
paths$processed <- paste0(paths$data, "/processed")
paths$metadata <- paste0(paths$root, "/metadata")
paths$reports <- paste0(paths$root, "/reports")

knitr::opts_knit$set(root.dir = paths$root)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

```

```{r load_files, message=F, results="hide"}
############################################################################
# FILES TO LOAD
############################################################################

# A. Tab delimited file with merged RSEM.genes.results files:
SampleDataFile <- file.path(paths$processed,"genes.data.tsv")

# B. Tab delimited sample information file with at least 2 columns:
#    1. sample names identical to the column names of sampleData
#    2. compound/group/whatever (needs to identify to which experimental group the sample belongs)
SampleKeyFile <- file.path(paths$metadata, "metadata.txt")

# Load input files
sampleData <- read.delim(SampleDataFile,
                         sep=sampledata_sep,
                         stringsAsFactors=FALSE,
                         header=TRUE, 
                         quote="\"",
                         row.names=1,
                         check.names=FALSE)

DESeqDesign <- read.delim(SampleKeyFile,
                          stringsAsFactors=FALSE,
                          sep="\t",
                          header=TRUE,
                          quote="\"",
                          row.names=NULL)

DESeqDesign$original_names <- DESeqDesign[,1]

############################################################################
# Arrange tables by sample names
############################################################################

sampleData <- sampleData %>% dplyr::relocate(colnames(sampleData) %>% sort())
ncol(sampleData)

#design
d <- DESeqDesign
d <- d %>% dplyr::arrange(original_names)
nrow(d)

############################################################################
#Checking row and column orderings
############################################################################
all(names(sampleData) == d$original_names)
```

# Sample Filtering Code

```{r read-count-filter-not-used, echo=F, eval=F}
############################################################################
# Filter by median read counts per gene per group
############################################################################
# Nominally, this is done for the groups under consideration instead.
# Done for each contrast within the RMarkdown script,
# so no need to run it here.
# 
# group <- unique(d$group)
# group <- group[order(group)]
# 
# #Way too many groups, lets use some parallel computing on this
# #okay this is much faster
# 
# cores=detectCores()
# cl <- makeCluster(cores[1]-1) #not to overload your computer
# registerDoParallel(cl)
# medcounts <- foreach(k = 1:length(group), .combine = cbind) %dopar%
#   apply(sampleData[,d$group == group[k]], 1, median)
# 
# stopCluster(cl)
# 
# gene_flag <- apply(medcounts, 1, max)
# quantile(gene_flag, probs = seq(0.1, 0.5, by = 0.1))
# 
# gene_flag <- gene_flag > 5
# 
# nrow(sampleData)
# sampleData <- sampleData[gene_flag,]
# p <- row.names(sampleData)
# nrow(sampleData)
```

## Dendogram and distance based filtering

A tree height cutoff of `r tree_height_cutoff` is used to cut the tree and separate outliers.

### Dendogram, all samples, prefiltering

Technical control samples are colored differently.

```{r dendogram_clustering}
############################################################################
# Function for sorting dendograms
############################################################################
sort_hclust <- function(...) as.hclust(dendsort(as.dendrogram(...)))

############################################################################
# Re-order the data by group
############################################################################
flag_order <- order(d$group)
d <- d[flag_order,]
sampleData <- sampleData[,flag_order]

############################################################################
# CPM (used in dendogram/cluster analysis)
############################################################################
libsize <- apply(sampleData, 2, sum)
cpm <- sampleData
for(k in 1:length(libsize)){
  cpm[,k] <- log2((10^6)*(sampleData[,k] + 0.5)/(libsize[k] + 1))
}

############################################################################
# Dendrogram: all
############################################################################
CairoPDF(file = file.path(paths$processed, "dendrogram_prefiltering_all.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_before_all_samples <- 1-cor(as.matrix(cpm), method = clust_method)
dendo_before_all_samples <- sort_hclust(hclust(as.dist(dendo_before_all_samples), method="average"))

dendo_before_all_samples <- as.dendrogram(dendo_before_all_samples)
colors_to_use <- as.numeric(as.factor(DESeqDesign[,technical_control]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_before_all_samples)]
labels_colors(dendo_before_all_samples) <- ordered_colors

original_names <- DESeqDesign[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_before_all_samples)]

labels_to_use <- DESeqDesign[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_before_all_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.15, mar = c(15, 4, 4, 2))
plot(dendo_before_all_samples %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()
```

### Filtering by Pearson correlation distance

In the code below, a `r clust_method` distance of `r tree_height_cutoff` is used to cut the tree and separate outliers.

```{r filtering_dendogram}
############################################################################
# Filtering
############################################################################

tree_groups <- cutree(dendo_before_all_samples, h = tree_height_cutoff)
n <- table(tree_groups)
n <- n[n == 1]

print("Samples Flagged:")

if(length(n > 0)){
  flag_cluster <- d$original_names %in% names(tree_groups[tree_groups %in% as.integer(names(n))])
  write.table(d[flag_cluster,],
              file.path(paths$processed, "outliers_cluster_analysis.txt"),
              sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
  d$group[flag_cluster]
}
```

### Splitting metadata into groups: technical controls and experimental samples

This section obtains sample names for technical controls, experimental samples, and reference RNA samples.

```{r split_metadata}
############################################################################
# Dendrogram: split into experimental samples vs technical controls
############################################################################

tech_ctrl_names <- DESeqDesign %>% 
  dplyr::filter(!!ensym(technical_control)==T) %>%
  dplyr::pull(original_names)

sample_names <- DESeqDesign %>% 
  dplyr::filter(!!ensym(technical_control)==F) %>%
  dplyr::pull(original_names)

ref_samples <- DESeqDesign %>% 
  dplyr::filter(!!ensym(reference_rna)==T) %>%
  dplyr::pull(original_names)

```

### Dendogram, technical controls, prefiltering

Colored by `r dendo_color_by`.

```{r dendo_tech_before}
############################################################################
# Technical Controls, Prefiltering
############################################################################
CairoPDF(file = file.path(paths$processed,
                          "dendrogram_prefiltering_tech_controls.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_before_tech_ctrls <- 1-cor(as.matrix(cpm %>% dplyr::select(all_of(tech_ctrl_names))),
                                           method = "spearman")
DESeqDesignTechCtrls <- DESeqDesign %>% dplyr::filter(original_names %in% all_of(tech_ctrl_names))

dendo_before_tech_ctrls <- sort_hclust(hclust(as.dist(dendo_before_tech_ctrls), method="average"))

dendo_before_tech_ctrls <- as.dendrogram(dendo_before_tech_ctrls)
colors_to_use <- as.numeric(as.factor(DESeqDesignTechCtrls[,dendo_color_by]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_before_tech_ctrls)]
labels_colors(dendo_before_tech_ctrls) <- ordered_colors

original_names <- DESeqDesignTechCtrls[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_before_tech_ctrls)]

labels_to_use <- DESeqDesignTechCtrls[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_before_tech_ctrls)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.4, mar = c(15, 4, 4, 2))
plot(dendo_before_tech_ctrls %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()


```

### Dendogram, experimental samples, prefiltering

First colored by `r dendo_color_by` and then colored by dose.  

The dose colored dendogram is hard-coded in this version and should be removed if your experiment does not involve dose-response (and therefore won't have a dose column in the metadata).  

```{r dendo_samples_before}
############################################################################
# Experimental Samples, Prefiltering
############################################################################

CairoPDF(file = file.path(paths$processed,
                          "dendrogram_prefiltering_exp_samples.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_before_all_exp_samples <- 1-cor(as.matrix(cpm  %>% dplyr::select(all_of(sample_names))),
                                  method = "spearman")

DESeqDesignExpSamples <- DESeqDesign %>% dplyr::filter(original_names %in% all_of(sample_names))

dendo_before_all_exp_samples <- sort_hclust(hclust(as.dist(dendo_before_all_exp_samples), method="average"))

dendo_before_all_exp_samples <- as.dendrogram(dendo_before_all_exp_samples)
colors_to_use <- as.numeric(as.factor(DESeqDesignExpSamples[,"dose"]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_before_all_exp_samples)]
labels_colors(dendo_before_all_exp_samples) <- ordered_colors

original_names <- DESeqDesignExpSamples[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_before_all_exp_samples)]

labels_to_use <- DESeqDesignExpSamples[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_before_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.2, mar = c(15, 4, 4, 2))
plot(dendo_before_all_exp_samples %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()

############################################################################
# Experimental Samples, Prefiltering, Colored by Dose
############################################################################

CairoPDF(file = file.path(paths$processed,
                          "dendrogram_prefiltering_exp_samples_by_dose.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_before_all_exp_samples <- 1-cor(as.matrix(cpm  %>% dplyr::select(all_of(sample_names))),
                                  method = "spearman")

DESeqDesignExpSamples <- DESeqDesign %>% dplyr::filter(original_names %in% all_of(sample_names))

dendo_before_all_exp_samples <- sort_hclust(hclust(as.dist(dendo_before_all_exp_samples), method="average"))

dendo_before_all_exp_samples <- as.dendrogram(dendo_before_all_exp_samples)
colors_to_use <- as.numeric(as.factor(DESeqDesignExpSamples[,dendo_color_by]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_before_all_exp_samples)]
labels_colors(dendo_before_all_exp_samples) <- ordered_colors

original_names <- DESeqDesignExpSamples[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_before_all_exp_samples)]

labels_to_use <- DESeqDesignExpSamples[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_before_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.2, mar = c(15, 4, 4, 2))
plot(dendo_before_all_exp_samples %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()

```

## Additional QC metrics

### Number of mapped reads

Samples less than `r nmr_threshold` aligned reads removed.

```{r num_mapped_reads}
######################################################################################
# Additional QC Metrics
######################################################################################
# NMR Number of mapped reads, defined as sum of total read counts summed over all detected probes
######################################################################################
# Reject < 300000 or Threshold = 10% of target depth
# Removes various types of failed samples

QAQC <- data.frame(Sample = names(sampleData), NMR = apply(sampleData, 2, sum))
failed_read_threshold <- QAQC[QAQC$NMR < nmr_threshold,]

# Samples failing
print("Samples Flagged:")
d %>%
  dplyr::filter(original_names %in% failed_read_threshold$Sample) %>%
  dplyr::pull(group)

```

### Number of active probes

The number of probes having >5 uniquely mapped reads are calculated. Outliers on that metric (i.e., outside 3XIQR) are removed from analysis.

```{r ncov5}
######################################################################################
# Ncov5 The number of probes with at least 5 uniquely mapped reads.
######################################################################################
# Tukey's Outer Fence cutoff - 3*IQR
n_genes <- nrow(sampleData)
QAQC$Ncov5 <- apply(sampleData, 2, function(x) length(x[x > 4]))/n_genes
percent_active_probes <- boxplot(QAQC$Ncov5, range=3, plot=F)
failed_Ncov5 <- QAQC[QAQC$Ncov5 < percent_active_probes$stats[1,1],]

# Samples failing
print("Samples Flagged:")
d %>%
  dplyr::filter(original_names %in% failed_Ncov5$Sample) %>%
  dplyr::pull(group)
```

### Number of probes capturing 80% of signal

The number of probes capturing 80% of the signal is first calculated, and samples falling outside of 3X IQR are removed from downstream analysis.

```{r nsig80}
######################################################################################
# Nsig80 - The number of probes capturing the top 80% of signal in a sample.
######################################################################################
# Tukey's Outer Fence cutoff - 3*IQR
# (include test samples, vehicle controls, and reference chemical treatments)

### Using some of the EPA code for now:
countStats <- function(
  counts, 
  nsig=getOption("httrStatNsig", default=0.8)
) {
  # Load required pkgs
	require(foreach)
  # Store results in a vector
	st <- vector()
	# Drop probes w/ no reads (this is for efficiency, should not impact final Nsig values)
	counts_nz <- counts[counts > 0]
	# Sort in decreasing order
	counts_nz <- sort(counts_nz, decreasing = T)
	# Compute cumulative sum of counts starting from highest count probe
	cumCounts <- cumsum(counts_nz)
	# Convert cumulative sums to cumulative proportions
	cumProp <- cumCounts / sum(counts_nz)
	# Compute the minimum number of probes to capture X% of total reads
	if(length(nsig) > 0) {
		ns <- foreach(prop=nsig, .combine='c') %do% {min(which(cumProp > prop))}
		names(ns) <- paste0("n_sig",nsig*100)
		st <- append(st, ns)
	}
	return(st)
}

# ref <- apply(sampleData/QAQC$NMR, 2, median)
# sig80 <- quantile(ref, prob = 0.8)
# 
# QAQC$Nsig80 <- 0
# 
# for(k in 1:nrow(QAQC)){
#   flag80pct <- sampleData[,k] > sig80 * QAQC$NMR[k]
#   QAQC$Nsig80[k] <- length(sampleData[flag80pct, 1])/n_samples
# }
# 

QAQC$Nsig80 <- apply(sampleData, 2, countStats)

probes_capturing_top_80 <- boxplot(QAQC$Nsig80, range=3, plot=F)
failed_Nsig80 <- QAQC[QAQC$Nsig80 < probes_capturing_top_80$stats[1,1],]

# Samples failing
print("Samples Flagged:")
d %>%
  dplyr::filter(original_names %in% failed_Nsig80$Sample) %>%
  dplyr::pull(group)

```

### Gini coefficient

The Gini coefficient is computed for each sample based on the distribution of raw counts for all probes including those with 0 aligned reads. Samples with Gini coefficients >0.95 are removed from the analysis.

```{r gini}
######################################################################################
# Gini coefficient - Gini coefficient computed for each sample based on the distribution of 
# raw counts for all probes including those with 0 aligned reads
######################################################################################
# Reject > 0.95
QAQC$Gini <- apply(sampleData, 2, function(x) gini(x))
failed_gini <- QAQC[QAQC$Gini > 0.95,]

# Samples failing
print("Samples Flagged:")
d %>%
  dplyr::filter(original_names %in% failed_gini$Sample) %>%
  dplyr::pull(group)
```

# Correlations

## All samples

This shows the Pearson correlation of log2-normalized CPM of read counts across all samples.

```{r correlation_1, fig.width=11, fig.height=10}
ref_correlations_all <- cor(as.matrix(cpm),
                            method = "pearson")

correlation_df_all <- DESeqDesign %>%
  filter(original_names %in% colnames(ref_correlations_all))

rownames(correlation_df_all) <- correlation_df_all$original_names
correlation_df_all <- correlation_df_all[colnames(ref_correlations_all),]

correlation_df_all_heatmap <- correlation_df_all[,c(groups,
                                                    technical_control,
                                                    reference_rna,
                                                    solvent_control)]

pheatmap(ref_correlations_all,
         show_rownames = F,
         show_colnames = F,
         border_color=NA,
         annotation_col = correlation_df_all_heatmap)

# Heatmap(ref_correlations_all,
#          top_annotation = correlation_df_all_heatmap)

```


## Experimental samples

This shows the Pearson correlation of log2-normalized CPM of read counts across experimental samples.  Technical controls are excluded.

```{r correlation_2, fig.width=11, fig.height=10}
ref_correlations_samples <- cor(as.matrix(cpm %>%
                                            dplyr::select(all_of(sample_names))),
                                method = "pearson")

correlation_df_samples <- DESeqDesign %>%
  filter(original_names %in% colnames(ref_correlations_samples))

rownames(correlation_df_samples) <- correlation_df_samples$original_names
correlation_df_samples <- correlation_df_samples[colnames(ref_correlations_samples),]

correlation_df_samples_heatmap <- correlation_df_samples[,c(groups,
                                                            technical_control,
                                                            reference_rna,
                                                            solvent_control)]

pheatmap(ref_correlations_samples,
         show_rownames = F,
         show_colnames = F,
         border_color=NA,
         annotation_col = correlation_df_samples_heatmap)

```


## Reference RNA

This tests the Pearson correlation of log2-normalized CPM of read counts. If your data includes reference RNA, it should be shown here. If your data includes two sources of reference RNA, the same standard mix should shower higher correlations than between different standards. The correlations for the same standards across different batches/plates should be relatively high.

```{r correlation_3, fig.width=11, fig.height=10}
ref_correlations <- cor(as.matrix(cpm %>%
                                      dplyr::select(all_of(ref_samples))),
                          method = "pearson")

correlation_df <- DESeqDesign %>%
  filter(original_names %in% colnames(ref_correlations))

row.names(correlation_df) <- correlation_df$original_names
correlation_df <- correlation_df[colnames(ref_correlations),]

correlation_df <- as.data.frame(correlation_df[,groups], drop=FALSE)

pheatmap(ref_correlations,
         annotation_col = correlation_df,
         display_numbers = T,
         cutree_cols = 2,
         cutree_rows = 2)

heatmap_colors <- circlize::colorRamp2(c(0.7, 1), c("blue", "red"))

annotation_col <- HeatmapAnnotation(df=correlation_df)

# Heatmap(ref_correlations,
#         name = "Correlation",
#         clustering_distance_rows = "pearson",
#         clustering_distance_columns = "pearson",
#         row_km = 2,
#         column_km = 2,
#         cell_fun = function(j, i, x, y, width, height, fill) {
#           grid.text(sprintf("%.2f", ref_correlations[i, j]), x, y, gp = gpar(fontsize = 10))
#           },
#         top_annotation = annotation_col,
#         col=heatmap_colors
#         )

# ref_correlations

```



# Compose tables

```{r return_data}

######################################################################################
# Add Dendogram Clustering Pass/Fail to QAQC
######################################################################################
QAQC$Dendogram <- "PASS"
QAQC$Dendogram[which(QAQC$Sample %in% d$original_names[flag_cluster])] <- "FAIL"

failed_dendo_clustering <- QAQC[QAQC$Denodogram == "FAIL",]

# Samples failing
d %>%
  dplyr::filter(original_names %in% failed_dendo_clustering$Sample) %>%
  dplyr::pull(group)

############################################################################
# Removing Outliers
############################################################################
QAQC_pass_fail <- QAQC
QAQC_pass_fail[QAQC$NMR < nmr_threshold,]$NMR <- "FAIL"
QAQC_pass_fail[QAQC$NMR >= nmr_threshold,]$NMR <- "PASS"
QAQC_pass_fail[QAQC$Ncov5 < percent_active_probes$stats[1,1],]$Ncov5 <- "FAIL"
QAQC_pass_fail[QAQC$Ncov5 >= percent_active_probes$stats[1,1],]$Ncov5 <- "PASS"
QAQC_pass_fail[QAQC$Nsig80 < probes_capturing_top_80$stats[1,1],]$Nsig80 <- "FAIL"
QAQC_pass_fail[QAQC$Nsig80 >= probes_capturing_top_80$stats[1,1],]$Nsig80 <- "PASS"
QAQC_pass_fail[QAQC$Gini > 0.95,]$Gini <- "FAIL"
QAQC_pass_fail[QAQC$Gini <= 0.95,]$Gini <- "PASS"
  
QAQC_failed <- QAQC_pass_fail %>%
  dplyr::rowwise() %>% 
  dplyr::filter_all(any_vars(str_detect(., pattern = "FAIL")))

QAQC_failed_logical <- as.data.frame(QAQC_failed)
QAQC_failed_logical[QAQC_failed_logical=="FAIL"] <- 1
QAQC_failed_logical[QAQC_failed_logical=="PASS"] <- 0
#apply(QAQC_failed_logical_matrix, 2, as.numeric)

QAQC_failed_logical <- QAQC_failed_logical %>%
  dplyr::left_join(d %>% dplyr::select(original_names, group),
                   by=(c("Sample"="original_names"))) %>%
  dplyr::mutate_if(is.character, as.numeric)

```

# Tables and plots

This section shows several tables of the outlier data.  

## UpSet plot and vtree plot of outliers

This plot shows the various QC metrics that may result in sample removal, along with the numbers of samples that were removed for one or more of those filters.  

If the "UpSet" plot makes you upset, please skip to the much more intuitive "vtree".


```{r upset-vtree}

upset(QAQC_failed_logical)

QAQC_annotated <- dplyr::left_join(DESeqDesign,
                                   QAQC_pass_fail,
                                   by=c("original_names"="Sample")) %>%
  dplyr::right_join(QAQC, by=c("name"="Sample"),
                   suffix = c("", "_data"))

QAQC_annotated$Any <- apply(QAQC_annotated,
                            MARGIN=1,
                            FUN = function(x) ifelse(any(x == "FAIL"),"FAIL","PASS"))

vtree(QAQC_annotated,
      "Dendogram NMR Ncov5 Nsig80 Gini Any",
      summary="NMR_data \nAverage Reads Mapped\n%mean% %leafonly% ")

vtree(QAQC_annotated,
      "Dendogram NMR Ncov5 Nsig80 Gini",
      summary="NMR_data \nAverage Reads Mapped\n%mean% %leafonly% ",
      pattern=T)

outliers <- QAQC_failed$Sample
outliers

flag_outliers <- d$original_names %in% outliers
outlier_metadata <- d[flag_outliers,]
metadata_outliers_removed <- DESeqDesign[!flag_outliers,] %>%
  filter(!!ensym(technical_control)==F)

```

## Potential covariates

This examines correlations between the QC metrics calculated and any factors in the experimental design.  

Please note that in these pairwise plots, some relationships are meaningless (e.g., dose vs dose).This is meant to explore trends that may not otherwise be apparent.  

```{r possible_covariates, fig.height=12, fig.width=12}

### Come back to this. How on earth can we automate this or make it generic!?
### Add in n vectors... a list of vectors to loop over?
### list(a,b,c) where a is ("row","column") ?
### Common columns - vector of NMR_data, Ncov5_data, Nsig80_data, Gini_data

QAQC_metadata_subset <- QAQC_annotated %>%
  dplyr::select(row,
                column,
                I7_Index_ID,
                I5_Index_ID,
                pool,
                dose,
                chemical,
                batch,
                NMR_data, Ncov5_data, Nsig80_data, Gini_data)

# This is too much.
# ggpairs(QAQC_metadata_subset,
#         cardinality_threshold = 24)

QAQC_metadata_subset$pool <- factor(QAQC_metadata_subset$pool)
QAQC_metadata_subset$dose <- factor(log(QAQC_metadata_subset$dose+1))

ggpairs(QAQC_metadata_subset,
        cardinality_threshold = 24,
        columns=c("row",
                  "column",
                  "NMR_data", "Ncov5_data", "Nsig80_data", "Gini_data"),
        ggplot2::aes(colour=batch))

ggpairs(QAQC_metadata_subset,
        cardinality_threshold = 24,
        columns=c("I7_Index_ID",
                  "I5_Index_ID",
                  "NMR_data", "Ncov5_data", "Nsig80_data", "Gini_data"),
        ggplot2::aes(colour=batch))

ggpairs(QAQC_metadata_subset,
        cardinality_threshold = 24,
        columns=c("pool",
                  "batch",
                  "NMR_data", "Ncov5_data", "Nsig80_data", "Gini_data"),
        ggplot2::aes(colour=batch))

ggpairs(QAQC_metadata_subset,
        cardinality_threshold = 24,
        columns=c("dose",
                  "chemical",
                  "NMR_data", "Ncov5_data", "Nsig80_data", "Gini_data"),
        ggplot2::aes(colour=batch))


```


## Plate position effects

```{r plate_pos}
ggplot(QAQC_annotated, aes(x = factor(column),
                           y = factor(row, levels=rev(levels(factor(row)))))) +
#  geom_tile(mapping=aes(fill = log(dose+1)), data=QAQC_annotated) +
#  scale_fill_gradient(low = "grey", high = "black") +
  geom_point(mapping=aes(color = NMR_data), data=QAQC_annotated, size=3) +
    scale_x_discrete(position = "top") +
  coord_fixed() +
  facet_wrap(~batch) +
  ggtitle("Number of mapped reads") +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

ggplot(QAQC_annotated, aes(x = factor(column),
                           y = factor(row, levels=rev(levels(factor(row)))))) +
#  geom_tile(mapping=aes(fill = log(dose+1)), data=QAQC_annotated) +
#  scale_fill_gradient(low = "grey", high = "black") +
  geom_point(mapping=aes(color = Nsig80_data), data=QAQC_annotated, size=3) +
    scale_x_discrete(position = "top") +
  coord_fixed() +
  facet_wrap(~batch) +
  ggtitle("Nsig80") +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

ggplot(QAQC_annotated, aes(x = factor(column),
                           y = factor(row, levels=rev(levels(factor(row)))))) +
#  geom_tile(mapping=aes(fill = log(dose+1)), data=QAQC_annotated) +
#  scale_fill_gradient(low = "grey", high = "black") +
  geom_point(mapping=aes(color = Ncov5_data), data=QAQC_annotated, size=3) +
    scale_x_discrete(position = "top") +
  coord_fixed() +
  facet_wrap(~batch) +
  ggtitle("Ncov5") +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

ggplot(QAQC_annotated, aes(x = factor(column),
                           y = factor(row, levels=rev(levels(factor(row)))))) +
#  geom_tile(mapping=aes(fill = log(dose+1)), data=QAQC_annotated) +
#  scale_fill_gradient(low = "grey", high = "black") +
  geom_point(mapping=aes(color = Gini_data), data=QAQC_annotated, size=3) +
    scale_x_discrete(position = "top") +
  coord_fixed() +
  facet_wrap(~batch) +
  ggtitle("Gini") +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

ggplot(QAQC_annotated, aes(x = factor(column),
                           y = factor(row, levels=rev(levels(factor(row)))))) +
  geom_tile(mapping=aes(fill = log(dose+1)), data=QAQC_annotated) +   
  scale_fill_gradient(low = "grey", high = "black") +
  geom_point(mapping=aes(color = Any), data=QAQC_annotated, size=3) +
    scale_x_discrete(position = "top") +
  coord_fixed() +
  facet_wrap(~batch) +
  ggtitle("Any samples failed") +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank(),
        axis.title.y = element_blank())
```


## Metadata of samples identified as outliers

```{r table_metadata}

knitr::kable(outlier_metadata,
             caption="Samples Removed") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  kableExtra::scroll_box(width = "100%", height = "480px")

QAQC_failed_kable <- outlier_metadata %>%
  dplyr::select(original_names, group) %>%
  left_join(QAQC_failed, by=(c("original_names"="Sample")))

```

## Pass/fail table for samples identified as outliers

```{r table_pass_fail}

knitr::kable(QAQC_failed_kable,
             caption="Which samples were removed and why?") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")


```


## Overall summary of pass/fail for each test

```{r pass_fail_summary}
QAQC_annotated %>%
  dplyr::group_by(Dendogram, NMR, Ncov5, Nsig80, Gini, Any) %>%
  tally() %>%
  knitr::kable(caption="Summary of pass/fail results")%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```

## Pass/fail for each test, broken up by sample groups

```{r pass_fail_by_group}
QAQC_annotated %>%
  dplyr::group_by(Dendogram, NMR, Ncov5, Nsig80, Gini, Any, group) %>%
  tally() %>%
  knitr::kable(caption="Pass/fail results by group")%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>%
  scroll_box(width = "100%", height = "480px")
```

## Write tables to disk

```{r write_output}

outlier_metadata_annotated <- dplyr::left_join(outlier_metadata,
                                               QAQC_pass_fail,
                                               by=c("original_names"="Sample"))
write.table(outlier_metadata_annotated,
            file.path(paths$processed, "samples_removed.txt"),
            sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

write.table(metadata_outliers_removed,
            file.path(paths$metadata, "metadata.QC_applied.txt"),
            sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

d_filtered <- d[!(flag_outliers),]
sampleData_filtered <- sampleData %>% dplyr::select(-all_of(outliers))
ncol(sampleData_filtered)
```

## Dendogram (after filtering)

### Dendogram, all samples, postfiltering

```{r dendogram_all_after}
############################################################################
# Dendrogram: all, after filtering
############################################################################

CairoPDF(file = file.path(paths$processed, "dendrogram_postfiltering_all.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_after_all_samples <- 1-cor(as.matrix(cpm %>% dplyr::select(-all_of(outliers))),
                                  method = "spearman")
dendo_after_all_samples <- sort_hclust(hclust(as.dist(dendo_after_all_samples), method="average"))

dendo_after_all_samples <- as.dendrogram(dendo_after_all_samples)
colors_to_use <- as.numeric(as.factor(DESeqDesign[,"technical_control"]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_after_all_samples)]
labels_colors(dendo_after_all_samples) <- ordered_colors

original_names <- DESeqDesign[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_after_all_samples)]

labels_to_use <- DESeqDesign[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_after_all_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.15, mar = c(15, 4, 4, 2))
plot(dendo_after_all_samples %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()
```

### Dendogram, technical control samples, postfiltering

```{r dendogram_technical_after}
############################################################################
# Technical Controls, Postfiltering
############################################################################
CairoPDF(file = file.path(paths$processed,
                          "dendrogram_postfiltering_tech_controls.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_after_tech_ctrls <- 1-cor(as.matrix(cpm %>%
                                            dplyr::select(all_of(tech_ctrl_names)) %>%
                                            dplyr::select(-all_of(outliers[outliers %in% tech_ctrl_names]))),
                                method = "spearman")

DESeqDesignTechCtrls <- DESeqDesign %>% dplyr::filter(original_names %in% all_of(tech_ctrl_names))

dendo_after_tech_ctrls <- sort_hclust(hclust(as.dist(dendo_after_tech_ctrls), method="average"))

dendo_after_tech_ctrls <- as.dendrogram(dendo_after_tech_ctrls)
colors_to_use <- as.numeric(as.factor(DESeqDesignTechCtrls[,dendo_color_by]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_after_tech_ctrls)]
labels_colors(dendo_after_tech_ctrls) <- ordered_colors

original_names <- DESeqDesignTechCtrls[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_after_tech_ctrls)]

labels_to_use <- DESeqDesignTechCtrls[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_after_tech_ctrls)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.4, mar = c(15, 4, 4, 2))
plot(dendo_after_tech_ctrls %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()
```

### Dendogram, experimental samples, postfiltering

```{r dendogram_exp_after}
############################################################################
# Experimental Samples, Postfiltering
############################################################################

CairoPDF(file = file.path(paths$processed,
                          "dendrogram_prefiltering_exp_samples.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_after_all_exp_samples <- 1-cor(as.matrix(cpm %>%
                                            dplyr::select(all_of(sample_names)) %>%
                                            dplyr::select(-all_of(outliers[outliers %in% sample_names]))),
                                  method = "spearman")

DESeqDesignExpSamples <- DESeqDesign %>% dplyr::filter(original_names %in% all_of(sample_names))

dendo_after_all_exp_samples <- sort_hclust(hclust(as.dist(dendo_after_all_exp_samples), method="average"))

dendo_after_all_exp_samples <- as.dendrogram(dendo_after_all_exp_samples)
colors_to_use <- as.numeric(as.factor(DESeqDesignExpSamples[,"dose"]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_after_all_exp_samples)]
labels_colors(dendo_after_all_exp_samples) <- ordered_colors

original_names <- DESeqDesignExpSamples[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_after_all_exp_samples)]

labels_to_use <- DESeqDesignExpSamples[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_after_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.2, mar = c(15, 4, 4, 2))
plot(dendo_after_all_exp_samples %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()
```

### Dendogram, experimental samples, postfiltering, colored by dose

```{r dendogram_exp_post_dose}
############################################################################
# Experimental Samples, Postfiltering, Colored by Dose
############################################################################

CairoPDF(file = file.path(paths$processed,
                          "dendrogram_prefiltering_exp_samples_by_dose.pdf"),
         width = 14,
         height = 8.5,
         family = "Courier")

dendo_after_all_exp_samples <- 1-cor(as.matrix(cpm %>%
                                                 dplyr::select(all_of(sample_names)) %>%
                                                 dplyr::select(-all_of(outliers[outliers %in% sample_names]))),
                                     method = "spearman")

DESeqDesignExpSamples <- DESeqDesign %>% dplyr::filter(original_names %in% all_of(sample_names))

dendo_after_all_exp_samples <- sort_hclust(hclust(as.dist(dendo_after_all_exp_samples), method="average"))

dendo_after_all_exp_samples <- as.dendrogram(dendo_after_all_exp_samples)
colors_to_use <- as.numeric(as.factor(DESeqDesignExpSamples[,dendo_color_by]))
ordered_colors <- colors_to_use[order.dendrogram(dendo_after_all_exp_samples)]
labels_colors(dendo_after_all_exp_samples) <- ordered_colors

original_names <- DESeqDesignExpSamples[,"original_names"]
original_names <- original_names[order.dendrogram(dendo_after_all_exp_samples)]

labels_to_use <- DESeqDesignExpSamples[,dendo_color_by]
labels_to_use <- labels_to_use[order.dendrogram(dendo_after_all_exp_samples)]
labels_to_use <- paste(labels_to_use, original_names)

par(cex=0.2, mar = c(15, 4, 4, 2))
plot(dendo_after_all_exp_samples %>% set("labels", labels_to_use),
     main = "log2 CPM",
     horiz = F)
abline(h=tree_height_cutoff, col = "red", lwd = 2)
dev.off()
```


## Plots of QC data metrics

### Batch

```{r plot_batch_effects}
ggplot(QAQC_annotated, aes(x=batch, color=chemical)) +
  geom_boxplot(aes(y=Gini_data)) +
  facet_grid(~batch, scales = "free_x") +
  ggtitle("Gini") +
  theme(legend.position = "bottom")

ggplot(QAQC_annotated, aes(x=batch, color=chemical)) +
  geom_boxplot(aes(y=NMR_data)) +
  facet_grid(~batch, scales = "free_x") +
  ggtitle("Number of Mapped Reads") +
  theme(legend.position = "bottom")

ggplot(QAQC_annotated, aes(x=batch, color=chemical)) +
  geom_boxplot(aes(y=Ncov5_data)) +
  facet_grid(~batch, scales = "free_x") +
  ggtitle("Proportion of active probes (% probes with >5 mapped reads)") +
  theme(legend.position = "bottom")

ggplot(QAQC_annotated, aes(x=batch, color=chemical)) +
  geom_boxplot(aes(y=Nsig80_data)) +
  facet_grid(~batch, scales = "free_x") +
  ggtitle("Proportion of probes required to account for 80% of signal") +
  theme(legend.position = "bottom")

```

### Dose effects

```{r plot_chemical_differences}
ggplot(QAQC_annotated, aes(x=chemical, color=factor(dose))) +
  geom_boxplot(aes(y=Gini_data)) +
  facet_wrap(~chemical, scales = "free_x") +
  ggtitle("Gini")

ggplot(QAQC_annotated, aes(x=chemical, color=factor(dose))) +
  geom_boxplot(aes(y=NMR_data)) +
  facet_wrap(~chemical, scales = "free_x") +
  ggtitle("Number of Mapped Reads")

ggplot(QAQC_annotated, aes(x=chemical, color=factor(dose))) +
  geom_boxplot(aes(y=Ncov5_data)) +
  facet_wrap(~chemical, scales = "free_x") +
  ggtitle("Proportion of active probes (% probes with >5 mapped reads)")

ggplot(QAQC_annotated, aes(x=chemical, color=factor(dose))) +
  geom_boxplot(aes(y=Nsig80_data)) +
  facet_wrap(~chemical, scales = "free_x") +
  ggtitle("Proportion of probes required to account for 80% of signal")

```
