---
title: "Transcriptome Profiling"
author: "Matthew J. Meier"
subtitle: "RNASeq Analysis"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: spacelab # flatly spacelab sandstone cerulean
params:
  species: rat # pick from human, mouse, rat, hamster
  design: "group" # a single experimental group of interest
  intgroup: "group" # experimental group of interest plus covariates; can be more than one
  flag: TRUE
  projectdir: "~/shared/projects/Template_RNASeq/" # Note trailing slash... we try to avoid requiring it though!
---

***

# Revision History

**This version**  
  
*Current version: 1*  
Date report generated: `r format(Sys.time(), '%d %B, %Y')`  
Report prepared for: Name  
Purpose of report:  

* Exercise to analyze RNA-Seq data  

**Previous revisions**  

N/A  

***

# Code setup, Data Loading, and DESeq2 Code

This report is meant to help explore DESeq2 results and was generated using RMarkdown. This section contains the code for setting up the rest of the report.  

## Load libraries

```{r docSetup, warning=FALSE, message=FALSE}
## Define paths
paths <- list()
paths$root <- params$projectdir
paths$data <- paste0(paths$root, "/data")
paths$raw <- paste0(paths$data, "/raw")
paths$output <- paste0(paths$data, "/output")
paths$processed <- paste0(paths$data, "/processed")
paths$metadata <- paste0(paths$root, "/metadata")
paths$reports <- paste0(paths$root, "/reports")
paths$DEG_output <- paste0(paths$root, "/DEG_output")

## knitrBoostrap and device chunk options
# Set so that long lines in R will be wrapped:
knitr::opts_chunk$set(bootstrap.show.code = FALSE,
                      bootstrap.panel = TRUE,
                      cache = TRUE)
#knitr::tidy.opts=list(width.cutoff=60), tidy=TRUE, crop = NULL # Use for PDFs
knitr::opts_knit$set(root.dir = paths$root)

# Set this variable to FALSE if you only want to run the plotting functions by reloading the last RData file.
flag=params$flag # To evaluate analysis chunks
if (flag==FALSE) { load(paste0(params$projectdir,"Partial_analysis.RData")) }
# Set this variable to TRUE if you would like to embed the files directly into the HTML for portability. This slows down page responsiveness drastically, since the files are generally quite large.
embedFiles=FALSE
# Se this variable to be TRUE if you want to have separate plots of top genes as defined in the R-ODAF template
R_ODAF_plots=FALSE 
```

```{r 'warn_user', eval=!flag}
message("If this text is visible by default, this report was produced to test plotting functions and should be used exclusively for testing and development.")
```

```{r setup, warning=FALSE, message=FALSE}
#### Record start time
startTime <- Sys.time()

#### Load Libraries
# General purpose
# library('conflicted')
library('knitr')
library('kableExtra')
library('tidyverse')
library('magrittr')
library('ggplot2')
library('DT')
library('data.table')
library('pheatmap')
library('lattice')
library('tidytext')
library('openxlsx')
library('RColorBrewer')
library('viridis')
library('sessioninfo')
library('plotly')
#library('RMariaDB')

# Bioinformatics-specific
library('DESeq2')
library('edgeR')
library('enrichplot')
library('rWikiPathways')
library('BiocParallel')
library('clusterProfiler')
library('biomaRt')
library('AnnotationHub')

# Not needed?
#library('regionReport')
#library('vsn')

# Load genome, depends on species
# To add: Zebrafish, Folsomia candida, others?
species <- params$species
if(species=="human"){
  # Human:
  library('org.Hs.eg.db')
  orgdb <- "org.Hs.eg.db"
  species_sci <- "Homo sapiens"
  ensembl_species <- "hsapiens_gene_ensembl"
  species_gene_symbol <- "external_gene_name"
} else {
    if(species=="mouse"){
      # Mouse:
      library('org.Mm.eg.db')
      orgdb <- "org.Mm.eg.db"
      species_sci <- "Mus musculus"
      ensembl_species <- "mmusculus_gene_ensembl"
      species_gene_symbol <- "mgi_symbol" 
    }
  else {
    if(species=="rat"){
      # Rat: 
      library('org.Rn.eg.db')
      orgdb <- "org.Rn.eg.db"
      species_sci <- "Rattus norvegicus"
      ensembl_species <- "rnorvegicus_gene_ensembl"
      species_gene_symbol <- "mgi_symbol"
    }
  else {
    if(species=="hamster"){
      # Golden hamster:
      OrgDb.Ma <- query(AnnotationHub(), c("OrgDb","Mesocricetus auratus"))[[1]]
      orgdb <- "OrgDb.Ma"
      species_sci <- "Mesocricetus auratus"
      ensembl_species <- "mauratus_gene_ensembl"
      species_gene_symbol <- "external_gene_name"
    }
  else {
    message("No species picked!")
  }
  }
  }
}

# Options
options(java.parameters = "-Xmx10000m")
theme_set(theme_bw())
```

The code above (not shown by default) loads the relevant R packages required for analysis.

## Specify parameters

```{r setup_code, warning=FALSE, message=FALSE, collapse=TRUE}
###################################################################################
###################################################################################
# PARAMETERS TO SET MANUALLY                            		 
#
# Set file locations
if(!dir.exists(paths$DEG_output)){
  dir.create(paths$DEG_output)
  }

# FILES TO LOAD
# A. Tab delimited file with merged RSEM.genes.results files:
SampleDataFile <- file.path(paths$processed,"genes.data.tsv")
# B. Tab delimited sample information file with at least 2 columns:
  # 1. sample names identical to the column names of sampleData
  # 2. compound/group/whatever (needs to identify to which experimental group the sample belongs)
SampleKeyFile <- file.path(paths$metadata,"metadata.txt")
# C. Tab delimited file of comparisons (contrasts) to test 
# Group of interest in the left column, control for comparison in the right column
ContrastsFile <- file.path(paths$metadata,"contrasts.txt")

# Specify which groups need to be compared 
contrasts <- read.delim(ContrastsFile, stringsAsFactors=FALSE, sep="\t", header=FALSE,  quote="\"")
short_contrast_names <- paste(contrasts$V1,"v.",contrasts$V2) # Customize these for your experiment... Must be short enough to fit as Excel tab titles.
DESIGN <- params$design	# Column name which defines the groups to be compared
intgroup <- params$intgroup # "Interesting groups" - an experimental group and/or covariates

# Various plotting and display options
nBestFeatures <- 20 # The number of best features to make plots of their counts
nBest <- 100 # Number of features to include in table and limiting PCA/clustering analysis
nHeatmap <- 50 # Number of most variable genes for heatmap
nHeatmapDEGs <- 50 # Number of DEGs for heatmap

# Set analysis ID. This ID will be used as prefix for the output files
analysisID <-"2020_DEFAULT"
# Specify used platform/technology for data generation:
Platform <- "RNA-Seq" # Specify "RNA-Seq" or "TempO-seq"

# Misc parameters
digits = 2 # For rounding numbers
```

The code above (not shown by default) specifies user preferences and data locations.

The experimental comparisons of interest are as follows: `r short_contrast_names`.

## Load data

```{r 'load_data', collapse=TRUE, warning=FALSE, message=FALSE, eval=flag}
# Load input files 
sampleData <- read.delim(SampleDataFile,
                         sep="\t",
                         stringsAsFactors=FALSE,
                         header=TRUE, 
                         quote="\"",
                         row.names=1,
                         check.names=FALSE)

DESeqDesign <- read.delim(SampleKeyFile,
                          stringsAsFactors=FALSE,
                          sep="\t",
                          header=TRUE,
                          quote="\"",
                          row.names=1) # Pick column that is used in ID; might be more appropriate to change this!

NORM_TYPE <- paste0(analysisID, "_DESeq2_", Platform)

plotdir <- paste(paths$DEG_output, "/plots/", sep="")
if(!dir.exists(plotdir)) {dir.create(plotdir)}
barplot.dir <- paste(plotdir, "/barplot_genes/", sep="")
if(!dir.exists(barplot.dir)) {dir.create(barplot.dir)}

```

The code above (not shown by default) loads user-provided meta data (i.e., information about your experiment, also known as colData, or, column data). This also imports the countx matrix (i.e., a table of observed counts in which each sample is a column and genes are rows).

## Run DESeq2

```{r run-DESeq2, collapse=TRUE, warning=FALSE, message=FALSE, eval=flag}
##########
# DESeq2 #
##########
print(NORM_TYPE) # Name of experiment

# First data clean-up: replace NA & remove samples with total readcount < threshold
threshold = 1000000
initialSampleDataCount <- ncol(sampleData)
sampleData[ is.na(sampleData) ] <- 0 
sampleData <- sampleData[,(colSums(sampleData) > threshold)] # 1 million reads required per sample
filteredSampleDataCount <- ncol(sampleData)
# Sometimes extra cleanup may be needed
# colnames(sampleData) <- gsub(pattern="^0", replacement="", x=colnames(sampleData))

samples_before <- nrow(DESeqDesign)
DESeqDesign$original_names <- rownames(DESeqDesign)

# Sanity check: each sample (row) in the metadata should have a corresponding column in the count data
metadata_in_sampledata <- all(rownames(DESeqDesign) %in% colnames(sampleData))
# Sanity check: each column in the count data should have a corresponding sample (row) in the metadata
sampledata_in_metadata <- all(colnames(sampleData) %in% rownames(DESeqDesign)) 
removed <- colnames(sampleData[which(!colnames(sampleData) %in% rownames(DESeqDesign))])
DESeqDesign <- DESeqDesign[(colnames(sampleData)),] # Reorder the metadata table to correspond to the order of columns in the count data
DESeqDesign <- na.omit(DESeqDesign)
# DESeqDesign <- DESeqDesign[ DESeqDesign$treatment != "human reference RNA",] # Remove samples manually
sampleData <- sampleData[,(rownames(DESeqDesign))]
samples_after <- nrow(DESeqDesign)

# For TempO-Seq: Limit sampleData matrix to genes in the assay.
if (Platform=="TempO-Seq") {
biospyder <- read.delim("~/dbs/biospyder/191113_Human_S1500_Surrogate_2.0_Manifest.csv", # Assay manifest...
                          stringsAsFactors=FALSE,
                          sep="\t",
                          header=TRUE,
                          quote="\"")
# biospyder %>% select(ENSEMBL_GENE_ID) %>% distinct() %>% count()
biospyder_annos <- biospyder %>% select(PROBE_NAME, ENSEMBL_GENE_ID, GENE_SYMBOL)
# sampleData <- sampleData[row.names(sampleData) %in% biospyder$ENSEMBL_GENE_ID,] # If aligned to hg38...
}

head(rownames(DESeqDesign))
head(colnames(sampleData)) # Output should match
intgroups <- params$intgroup
if (file.exists(file.path(paths$DEG_output, "dds.Rdata"))) {
  print(paste("Already found DESeq2 object from previous run; loading from disk."))
  load(file.path(paths$DEG_output,"/dds.Rdata"))
  if (!identical(as.data.frame(round(counts(dds))),
                 round(sampleData),0)) {
    print("Not identical")
    }
  } else {
  dds <- DESeqDataSetFromMatrix(countData = round(sampleData),
                                colData = as.data.frame(DESeqDesign),
                                design = formula(paste("~",intgroups)) )
  dds <- dds[,rownames(DESeqDesign)]
  dds <- dds[rowSums(counts(dds)) > 1]
  dds <- DESeq(dds, parallel = TRUE, BPPARAM=MulticoreParam(39))
  save(dds, file=file.path(paths$DEG_output,"dds.Rdata"))
  }

# ### REMOVE if done above from scratch
# keep <- grep(colData(dds)$chemical, pattern="cells", invert=T, ignore.case = T)
# dds <- dds[,keep]
# dds <- dds[row.names(dds) %in% biospyder$ENSEMBL_GENE_ID,]

# Another sanity check to make sure the object looks correct
resultsNames(dds)
head(colData(dds))
head(assay(dds))
head(rowRanges(dds))
str(counts(dds))

#Set parameters according to platform
if (Platform=="RNA-Seq"){
  MinCount<- 1
  alpha <- pAdjValue <- 0.05 # Relaxed from 0.01
  linear_fc_filter = 1.5
} else if (Platform=="TempO-Seq") {
  MinCount<- 0.5
  alpha <- pAdjValue<- 0.05 
  linear_fc_filter = 1.5
} else { print("Platform/technology not recognized") }


# Make regularized log object for later plotting
#rld <- tryCatch(rlog(dds), error = function(e) { rlog(dds, fitType = 'mean') })
# Use vst for hundreds of samples!
rld <- vst(dds) # Should this be blind?
 
```

The code above (not shown by default) uses DESeq2 `r packageVersion("DESeq2")` to test for differentially abundant genes within the `r Platform` data.  

Prior to running DESeq2, the data was filtered to remove samples that do not have `r threshold` reads per sample.  

The user-provided metadata initially included `r samples_before` samples.  

The count matrix initially included `r initialSampleDataCount` samples (including any reference material samples). After removing samples with less than `r threshold` reads, `r filteredSampleDataCount` samples were left. It is `r metadata_in_sampledata` that all the samples provided in the metadata table were also identified in the count matrix. It is `r sampledata_in_metadata` that all the samples in the count matrix were also identified in the metadata table.  

Following the removal of other samples (i.e., reference RNA, etc.), there were `r samples_after` samples remaining in the experiment. The samples excluded from analysis were named: `r paste(removed)`.    

## Sample data (metadata about your experiment) 

This table shows the final list of samples that were used in the data analysis (as well as corresponding sample information as it was communicated to the Genomics Laboratory).  

```{r print_metadata}
knitr::kable(DESeqDesign %>% arrange(!!sym(params$design)),
             row.names =  F,
             caption="User-provided information about samples and experimental conditions") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))  %>%
  scroll_box(width = "720px")
```

## Load R-ODAF functions

```{r 'define-ODAF-functions', collapse=TRUE, warning=FALSE, message=FALSE}
###################################################################################
#DEFINE FUNCTIONS
###################################################################################
plot.barplots<-function(samples,b) {
  color <- NULL
  for (h in 1:ncol(norm_data)){
    if (substring(colnames(norm_data)[h], 1, 3) == substring(condition2, 1, 3)) { color <- c(color, "red3") } else { color <- c(color, "darkgrey")}
  }
  fileNamePlot <- paste0(b, row.names(samples)[b], ".png")
  pseudoTitle <- paste0(row.names(samples)[b], "_pAdj:", samples[b,"padj"])
  
  png(file=paste(fileNamePlot, sep="/"), width=1200, height=700, pointsize=20)
  par(mar=c(8,4,3,1))
  barplot(as.numeric(norm_data[row.names(samples)[b],]), las=2, col=color, main=pseudoTitle, cex.names=0.5,  cex.axis=0.8, names.arg=colnames(norm_data)) 
  dev.off()
} #plot.barplots function done

###################################################################################
draw.barplots<-function(samples, top_bottom, NUM){
  if (nrow(samples) == 0) {
    #print("no genes to plot") 
  } else { 
    if (top_bottom == "top") {
      #print(paste0("drawing Top ", NUM, " plots"))
      if (nrow(samples) <= NUM) { 
        for (b in 1:nrow(samples)) {plot.barplots(samples,b)}
      }
      
      if (nrow(samples) > NUM) { 
        for (b in 1:NUM) {plot.barplots(samples,b)}	
      }	
    }
    
    if (top_bottom == "bottom") {
      #print(paste0("drawing Bottom", NUM, " plots"))
      if (nrow(samples) <= NUM) { 
        for (b in 1:nrow(samples)) {plot.barplots(samples,b)}
      }
      if (nrow(samples) > NUM) { 
        for (b in ((nrow(samples)-NUM+1):nrow(samples))) {plot.barplots(DEsamples,b)}
      }
    }}
} #draw.barplots function done

###################################################################################
###################################################################################
```

The code above (not shown by default) loads in plotting functions specific to the Omics Data Analysis Frameworks for Regulatory application (R-ODAF) template. More information on the R-ODAF framework is available [here](https://github.com/MCTverheijen/R-ODAF).

## Run pairwise comparisons

```{r 'run_ODAF_code', collapse=TRUE, warning=FALSE, message=FALSE, eval=flag}
cooks <- FALSE # Normally set Cook's cutoff to false
resList <- list()
for (x in 1:nrow(contrasts)) {	## for all comparisons to be done	
	
  condition1 <- contrasts[x,2]
	condition2 <- contrasts[x,1]
	print(paste(condition2, " vs ", condition1, ":", NORM_TYPE))
	
	DE_Design <- matrix(data=NA, ncol=2)
	DE_Design <- DESeqDesign[c(grep(condition1,DESeqDesign[,DESIGN]), grep(condition2,DESeqDesign[,DESIGN])),]
	samples <- sampleData[, rownames(DE_Design) ]
	colnames(samples) <- NULL
	
	###########

	print(paste0("Filtering genes: 75% of at least 1 group need to be above ", MinCount, " CPM"))
	print("AND")
	print("Detecting spurious spikes: Max-Median > Sum/(Rep+1)" )
		SampPerGroup<-table(DE_Design[,DESIGN])
		idx<-FlagSpike<-NameRows<-NULL
		Counts<-counts(dds, normalized=TRUE)
		CPMdds<-cpm(counts(dds, normalized=TRUE))
		for (gene in 1:nrow(dds)) {
			GroupsPass <- checkSpike<-NULL
			for (group in 1:length(SampPerGroup)) { #test if group passes
				sampleCols<-grep(dimnames(SampPerGroup)[[1]][group],DE_Design[,DESIGN])
				Check<-sum(CPMdds[gene,sampleCols] >= MinCount)>= 0.75*SampPerGroup[group]
				GroupsPass<-c(GroupsPass, Check)
				if (Check == FALSE) {checkSpike<- c(checkSpike, Check)} else {
					checkSpike<-c(checkSpike, ((max(Counts[gene,sampleCols])-median(Counts[gene,sampleCols])) >=
					                             (sum(Counts[gene,sampleCols])/(SampPerGroup[group]+1))))
				}
			}
			idx <- c(idx, as.logical(sum(GroupsPass)))
			if (sum(checkSpike) >=1) {
				FlagSpike<-rbind(FlagSpike, Counts[gene,])
				NameRows<<-c(NameRows, row.names(Counts)[gene])
				row.names(FlagSpike)<-NameRows 
			}
		}

	print("Obtaining the DESeq2 results")
	currentContrast <- c(DESIGN, condition2, condition1)
	res <- results(dds[idx],
	               parallel = TRUE, BPPARAM=MulticoreParam(39),
	               contrast=currentContrast,
	               pAdjustMethod= 'fdr',
	               cooksCutoff=cooks) # Cooks cutoff disabled - manually inspect.
	res <- lfcShrink(dds=dds[idx],
	                 contrast=currentContrast,
	                 res=res,
	                 type="ashr")
	#Make new directory for the ODAF-specific files
	ODAFdir <- file.path(paths$DEG_output, "R-ODAF")
	if(!dir.exists(ODAFdir)) {dir.create(ODAFdir)}
	setwd(ODAFdir)
	FileName <- paste(NORM_TYPE, condition2,"vs",condition1, "FDR", pAdjValue, sep="_")		
	#Save output tables		
	norm_data <<- counts(dds[idx],normalized=TRUE)
	colnames(norm_data) <- colData(dds)[,DESIGN]
	write.table(norm_data,file=paste0(FileName, "_Norm_Data.txt"), sep="\t", quote=FALSE)
	write.table(FlagSpike,file=paste0(FileName, "_FlaggedSpikes.txt"), sep="\t", quote=FALSE)
	DEsamples <<- subset(res,res$padj < pAdjValue)	
	write.table(DEsamples,file=paste0(FileName,"_DEG_table.txt"), sep="\t", quote=FALSE)
	DEspikes <<- DEsamples[rownames(DEsamples)%in%NameRows,]	
	write.table(DEspikes,file=paste0(FileName,"_DEspikes_table.txt"), sep="\t",quote=FALSE)

	resList[[x]] <- res
	
	if (R_ODAF_plots==TRUE) {
  	print("creating Read count Plots")
  	# top DEGs
  	plotdir <- file.path(paths$DEG_output, "plots")
  	if(!dir.exists(plotdir)) {dir.create(plotdir)}
  	barplot.dir <- file.path(paths$DEG_output, "plots", "/barplot_genes/")
  	if(!dir.exists(barplot.dir)) {dir.create(barplot.dir)}
  
  	TOPbarplot.dir <- file.path(barplot.dir, "Top_DEGs")
  	if(!dir.exists(TOPbarplot.dir)) {dir.create(TOPbarplot.dir)}
  	setwd(TOPbarplot.dir)
  	draw.barplots(DEsamples, "top", 20) # (DEsamples, top_bottom, NUM)
  	print("Top 20 DEG plots done")
  
  	# Spurious spikes
  	SPIKEbarplot.dir <- file.path(barplot.dir, "DE_Spurious_spikes")
  	if(!dir.exists(SPIKEbarplot.dir)) {dir.create(SPIKEbarplot.dir)}
  	setwd(SPIKEbarplot.dir)
  	draw.barplots(DEspikes, "top", nrow(DEspikes)) # (DEsamples, top_bottom, NUM)
  	print("All DE_Spurious_spike plots done")
	}
}
```

The code above (not shown by default) runs the R-ODAF spurious spike detection and outputs the DESeq Results objects as a list for each contrast. As specified by the R-ODAF guidelines, 75% of at least 1 group need to be above `r MinCount` CPM and spurious spikes were removed in which Max-Median > Sum/(Rep+1).  

The log2FoldChange shrinkage procedure used was `r resList[[1]]@priorInfo$type`. An alpha of `r resList[[1]]@metadata$alpha` was used to extract raw results, which are reported as the `r gsub(mcols(x=resList[[1]])$description[[4]],pattern=":.*",replacement="")`. To account for multiple testing, `r mcols(resList[[1]])$description[5]` are reported. Cook's cutoff was set to `r cooks` in this analysis.  


## Create summary tables

```{r create_tables, collapse=TRUE, warning=FALSE, message=FALSE, eval=flag}
#listEnsembl()
#listMarts()
#listDatasets(useMart('ensembl'))
ensembl <- useMart("ensembl", dataset = ensembl_species,  host = "useast.ensembl.org")
#listAttributes(ensembl)
#listFilters(ensembl)

genes <- row.names(resList[[1]])

#genes_all <- unique(row.names(assay(dds)))
setwd(paths$DEG_output) # Should avoid this... change ASAP
if (file.exists("id_table.Rdata")) {
  print(paste("Already found ID table; skipping biomaRt query and loading from disk."))
  load("./id_table.Rdata")
  id_table <- id_table_entrez[,1:3]
  } else {
  id_table_entrez <- getBM(filters="ensembl_gene_id",
                        attributes= c("ensembl_gene_id",
                                      "external_gene_name", # mgi_symbol for Mouse
                                      "description",
                                      "entrezgene_id"), # "refseq_mrna" or "refseq_peptide" may be of interest, but can't join with gene tables.
                        values=genes,
                        mart=ensembl)
  save(id_table_entrez, file="./id_table.Rdata")
  id_table <- id_table_entrez[,1:3]
}

genes_entrezid <- dplyr::left_join(data.frame(ensembl_gene_id=genes), id_table_entrez, by="ensembl_gene_id")

sigtabList <- list()
alltablList <- list()
for (i in 1:length(resList)) {
  print(i)
  sigTab <- resList[[i]]
  # Add taxonomy
  if (nrow(sigTab) == 0) {
    next
  } else {
    sigTab <- cbind(ensembl_gene_id=row.names(resList[[i]]),
                    as(sigTab, "data.frame"),
                    contrast = gsub(pattern = paste0("log2.*", DESIGN, "\ "),
                                    replacement =  "",
                                    x = resList[[i]]@elementMetadata[[2]][2]))
    sigTab <- dplyr::left_join(sigTab,
                               id_table,
                               by="ensembl_gene_id")
    sigTab <- dplyr::mutate(sigTab, linearFoldChange=ifelse(log2FoldChange > 0,
                                                            2 ^ log2FoldChange,
                                                            -1 / (2 ^ log2FoldChange)))
    #sigTab <- sigTab[,c(1,9,10,2,3,11,5:8)] # Reorder columns
    sigTab <- sigTab[,c(1,8,9,2,3,10,4:7)] 
    alltablList[[i]] <- sigTab
    sigTab <- sigTab[!is.na(sigTab$padj) & sigTab$padj < alpha & abs(sigTab$linearFoldChange) > linear_fc_filter, ] ## FILTERS!
    sigtabList[[i]] <- sigTab %>% dplyr::distinct()
  }
}
# Write dataframe of all results
# Significant only
sigtabList <- sigtabList[!sapply(sigtabList, is.null)]
significantResults <- rbindlist(sigtabList)
significantResults <- dplyr::distinct(significantResults)
# All results including non-significant
allResults <- rbindlist(alltablList)



# All Results for Plotting
# Replace NA gene symbols with ensembl ID
allResults$external_gene_name[is.na(allResults$external_gene_name)] <- allResults$ensembl_gene_id[is.na(allResults$external_gene_name)] 
# Replace blank gene symbols with ensembl ID
allResults$external_gene_name[allResults$external_gene_name == ""]  <- allResults$ensembl_gene_id[allResults$external_gene_name == ""]  
allResults$padj[allResults$padj == 0] <- 10^-100 # For plotting purposes!
allResultsOrdered_logFC_filter <- dplyr::filter(allResults, abs(linearFoldChange) > 1.5) %>%
  arrange(-abs(linearFoldChange))
allResultsOrdered_logFC_filter <- dplyr::filter(allResultsOrdered_logFC_filter, padj < alpha)
res.df <- allResultsOrdered_logFC_filter

degTable <- significantResults %>% 
  dplyr::group_by(contrast) %>%
  dplyr::count()

lengths <- lapply(resList, nrow)
longest <- which.max(lengths)
summaryTable <- data.frame( ensembl_gene_id=row.names(resList[[longest]]),
                            baseMean=resList[[longest]]$baseMean )
contrastsInSummary <- vector()
for (i in 1:length(resList)) {
  print(i)
  n <- resList[[i]]@elementMetadata[[2]][2]
  n <- gsub(pattern = paste0("log2\ fold\ change\ \\(MMSE\\):\ ",DESIGN), # Might need to be MLE for some tests
            replacement =  paste0("log2 Fold Change"),
            x = resList[[i]]@elementMetadata[[2]][2])
  p <- gsub(pattern = paste0("log2\ fold\ change\ \\(MMSE\\):\ ",DESIGN),
           replacement =  resList[[i]]@elementMetadata[[2]][6], # Not used?
           x = resList[[i]]@elementMetadata[[2]][2])
  q <- gsub(pattern = paste0("log2\ fold\ change\ \\(MMSE\\):\ ",DESIGN,"\ "),
            replacement =  "",
            x = resList[[i]]@elementMetadata[[2]][2])
  message(n)
  message(p)
  message(q)
  toJoin <- as.data.frame(resList[[i]])
  setDT(toJoin, keep.rownames = T)[]
  setnames(toJoin, 1, "ensembl_gene_id")
  toJoin <- mutate(toJoin, linearFoldChange=ifelse(log2FoldChange > 0,
                                                2 ^ log2FoldChange,
                                                -1 / (2 ^ log2FoldChange)))
  toJoin <- toJoin[,c(1:3,7,4:6)]
  summaryTable <- dplyr::left_join(summaryTable, dplyr::select(toJoin, !c(baseMean,pvalue,lfcSE)), by="ensembl_gene_id")

  names(summaryTable)[[ncol(summaryTable)-2]] <- paste0("log2FoldChange_",i)
  names(summaryTable)[[ncol(summaryTable)-1]] <- paste0("linearFoldChange_",i)
  names(summaryTable)[[ncol(summaryTable)]] <- paste0("FDR_",i)
  contrastsInSummary[i] <- q
  print(summary(resList[[i]], pAdjValue))
}
maxFCs <- allResults %>%
  dplyr::group_by(ensembl_gene_id) %>%
  dplyr::filter(abs(linearFoldChange) == max(abs(linearFoldChange))) %>%
  dplyr::ungroup() %>%
  dplyr::select(ensembl_gene_id, linearFoldChange)

minPvals <- allResults %>%
  group_by(ensembl_gene_id) %>%
  dplyr::filter(padj == min(padj)) %>%
  dplyr::ungroup() %>%
  dplyr::select(ensembl_gene_id, padj)

summaryTable <- summaryTable %>%
  left_join(id_table, by="ensembl_gene_id") %>%
  left_join(maxFCs, by="ensembl_gene_id") %>%
  left_join(minPvals, by="ensembl_gene_id") %>%
  dplyr::rename(maxFoldChange = linearFoldChange,
         minFDR_pval = padj
         ) %>%
  mutate(maxFoldChange=abs(maxFoldChange))

numColsToPrepend <- ncol(summaryTable) - 3*length(resList) - 2 # Number of columns per contrast = 3. Subtract two for the baseMean and ensembl_gene_id columns.
colPositionsToPrependSTART <- ncol(summaryTable) - numColsToPrepend + 1
colPositionsOfData <- ncol(summaryTable) - numColsToPrepend
summaryTable <- summaryTable[,c(1,
                                colPositionsToPrependSTART:ncol(summaryTable),
                                2:colPositionsOfData)]

CPMddsDF <- data.frame(ensembl_gene_id = row.names(CPMdds), CPMdds, check.names=F)
CPMddsDF <- dplyr::left_join(CPMddsDF, id_table, by="ensembl_gene_id")
numColsToPrepend <- ncol(CPMddsDF) - ncol(CPMdds) - 1
colPositionsToPrependSTART <- ncol(CPMddsDF) - numColsToPrepend + 1
colPositionsOfData <- ncol(CPMddsDF) - numColsToPrepend
CPMddsDF <- CPMddsDF[,c(1,colPositionsToPrependSTART:ncol(CPMddsDF),2:colPositionsOfData)]
```

The code above (not shown by default) generates tables summarzing the differentially expressed genes (DEGs).  

Here is the number of DEGs in each group:

```{r 'display_DEG_summary'}
kable(degTable,
      caption="Number of differentially expressed genes across each contrast") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

```{r 'write-tables', collapse=TRUE, warning=FALSE, message=FALSE, eval=flag}
#######################################
### Write results table from DESeq2
#######################################
setwd(paths$DEG_output)
write.table(allResults,         file=paste0(NORM_TYPE,"-DESeq_output_ALL.txt"),               quote=F, sep='\t', col.names=NA)
write.table(significantResults, file=paste0(NORM_TYPE,"-DESeq_output_significant.txt"),       quote=F, sep='\t', col.names=NA)
write.table(summaryTable,       file=paste0(NORM_TYPE,"-DESeq_output_all_genes.txt"),         quote=F, sep='\t', col.names=NA)
write.table(CPMddsDF,           file=paste0(NORM_TYPE,"-Per_sample_CPM.txt"),                 quote=F, sep='\t', col.names=NA)
write.table(Counts,             file=paste0(NORM_TYPE,"-Per_sample_normalized_counts.txt"),   quote=F, sep='\t', col.names=NA)
```

The code above (not shown by default) writes text files for each DEG summary type.

# Write data

```{r 'write-excel-worksheets', collapse=TRUE, warning=FALSE, message=FALSE, eval=flag}
setwd(paths$DEG_output)
#######################################
### Write results above but in Excel
#######################################
### Global options
options("openxlsx.borderColour" = "#4F80BD")
options("openxlsx.borderStyle" = "thin")
options("openxlsx.maxWidth" = 50)
hs1 <- createStyle(textDecoration = "Bold",
                   border = "Bottom",
                   fontColour = "black")
hs2 <- createStyle(textDecoration = "Bold",
                   border = c("top", "bottom", "left", "right"),
                   fontColour = "black",
                   fgFill="#C5D9F1")

### Summary results - one gene per line, columns are contrasts
wb1 <- createWorkbook()
modifyBaseFont(wb1, fontSize = 10, fontName = "Arial Narrow")
addWorksheet(wb1, "DESeq_results_per_gene")
for (j in 1:length(contrastsInSummary)) {
  myStartcol=7+((j-1)*3)
  myEndcol=9+((j-1)*3)
  mergeCells(wb1,
             sheet = 1,
             cols = myStartcol:myEndcol,
             rows = 1)
  writeData(
    wb1,
    sheet = 1,
    x = contrastsInSummary[j],
    startCol = myStartcol,
    startRow = 1)
}
conditionalFormatting(wb1,
                      sheet = 1,
                      rows = 1,
                      cols = 1:ncol(summaryTable),
                      type = "contains",
                      rule = "",
                      style=hs2)
freezePane(wb1, sheet = 1, firstActiveRow = 3, firstActiveCol = 4)
writeDataTable(wb1,
               sheet = 1,
               startRow = 2,
               x = summaryTable,
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb1, sheet = 1, cols = 1:6, widths = "auto") # This is hard-coded, so prone to error; will only impact auto adjustment of col widths.
setColWidths(wb1, sheet = 1, cols = 7:ncol(summaryTable), widths = 13) # This is hard-coded, so prone to error; will only impact auto adjustment of col widths.
fname1 <- paste0("1.",NORM_TYPE,"-DESeq_by_gene.xlsx")
saveWorkbook(wb1, fname1, overwrite = TRUE)

### All results in one table
wb2 <- createWorkbook()
modifyBaseFont(wb2, fontSize = 10, fontName = "Arial Narrow")
addWorksheet(wb2, paste0("FDR",pAdjValue,".Linear.FC.",linear_fc_filter))
freezePane(wb2, sheet = 1, firstRow = TRUE, firstActiveCol = 4)
writeDataTable(wb2,
               sheet = 1,
               x = significantResults,
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb2, sheet = 1, cols = 1:ncol(significantResults), widths = "auto")
addWorksheet(wb2, "DESeq_all_results")
freezePane(wb2, sheet = 2, firstRow = TRUE, firstActiveCol = 4)
writeDataTable(wb2,
               sheet = 2,
               x = allResults,
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb2, sheet = 2, cols = 1:ncol(allResults), widths = "auto")
saveWorkbook(wb2, paste0("2.",NORM_TYPE,"-DESeq_all.xlsx"), overwrite = TRUE)

### All results with different tabs for each contrast
wb3 <- createWorkbook()
modifyBaseFont(wb3, fontSize = 10, fontName = "Arial Narrow")

short_contrast_names <- stringr::str_trunc(short_contrast_names, 30, side="center")

for (i in 1:length(levels(factor(allResults$contrast)))) {
  print(i)
  dataToWrite <- allResults[allResults$contrast==levels(allResults$contrast)[i],]
  addWorksheet(wb3, short_contrast_names[i])
  freezePane(wb3, sheet = i, firstRow = TRUE, firstActiveCol = 4)
  writeDataTable(wb3,
                 sheet = i,
                 x = dataToWrite,
                 colNames = TRUE,
                 rowNames = F,
                 tableStyle = "none",
                 headerStyle = hs1,
                 keepNA = T,
                 na.string = "NA")
  setColWidths(wb3, sheet = i, cols = 1:ncol(dataToWrite), widths = "auto")
}
saveWorkbook(wb3, paste0("3.",NORM_TYPE,"-DESeq_by_contrast.xlsx"), overwrite = TRUE)

### CPM
wb4 <- createWorkbook()
modifyBaseFont(wb4, fontSize = 10, fontName = "Arial Narrow")
addWorksheet(wb4, "Counts per million")
freezePane(wb4, sheet = 1, firstRow = TRUE, firstActiveCol = 4)
writeDataTable(wb4,
               sheet = 1,
               x = as.data.frame(CPMddsDF),
               colNames = TRUE,
               rowNames = F,
               tableStyle = "none",
               headerStyle = hs1,
               keepNA = T,
               na.string = "NA")
setColWidths(wb4, sheet = 1, cols = 1:ncol(CPMddsDF), widths = "auto")
saveWorkbook(wb4, paste0("4.",NORM_TYPE,"-CPM.xlsx"), overwrite = TRUE)
```


The code above (not shown by default) writes Excel workbooks and text files of DEG lists.

These files should be provided to you as a separate zip file.

```{r 'embed_excel_files', eval=embedFiles}
setwd(paths$DEG_output)
xfun::embed_files(list.files(".", "[.](xlsx)$"), name = "RNASeq_Spreadsheets.zip")
```

```{r 'embed_text_files', eval=embedFiles}
setwd(paths$DEG_output)
xfun::embed_files(list.files(".", "[.](txt)$"), name = "RNASeq_Text_Files.zip")
```

```{r 'embed_ODAF_files', eval=embedFiles}
setwd(paths$DEG_output)
xfun::embed_dir(ODAFdir, name = "RNASeq_R-ODAF_text_files.zip")
```

```{r 'save_point', show=FALSE, eval=flag}
# Save RData here if flag is TRUE.
setwd(paths$DEG_output)
save.image(file = "Partial_analysis.RData")
# Add a flag to the start of the script with if statements in all code chunks to check if the flag is set.
# If flag is TRUE, run analysis; if flag is FALSE, SKIP analysis and continue here (just to modify plotting output).
```

# PCA Plots {.tabset}

## All genes, before filtering

```{r 'PCA'}
## Perform PCA analysis and make plot
plotPCA(rld, intgroup = params$intgroup, ntop=nrow(assay(rld)))
## Get percent of variance explained
data_pca <- plotPCA(rld, intgroup = params$intgroup, ntop=nrow(assay(rld)), returnData = TRUE)
percentVar <- round(100 * attr(data_pca, "percentVar"))

# PCAplot <- plotPCA(rld, intgroup = c("dose","group","treatment"), ntop=nrow(assay(rld)), returnData = TRUE)
# ggplot(PCAplot, aes(PC1, PC2, color=dose)) +
#   geom_point(size=1) +
#   xlab(paste0("PC1: ",percentVar[1],"% variance")) +
#   ylab(paste0("PC2: ",percentVar[2],"% variance")) +
#   coord_fixed()


```

This plot shows the first two principal components that explain the variability in the data using the regularized log count data. If you are unfamiliar with principal component analysis, you might want to check the [Wikipedia entry](https://en.wikipedia.org/wiki/Principal_component_analysis) or this [interactive explanation](http://setosa.io/ev/principal-component-analysis/). In this case, the first and second principal component explain `r percentVar[1]` and `r percentVar[2]` percent of the variance respectively.

## DEGs only

```{r 'PCA_DEGs'}
rld_degs <- rld[row.names(assay(rld)) %in% significantResults$ensembl_gene_id,]
## Perform PCA analysis and make plot
plotPCA(rld_degs, intgroup = params$intgroup, ntop=nrow(rld_degs)) #+ theme(legend.position = "none")
PCAplotDEGs <- plotPCA(rld_degs, params$intgroup = c("dose","group","treatment"), ntop=nrow(assay(rld_degs)), returnData = TRUE)

# ggplot(PCAplotDEGs, aes(PC1, PC2, color=dose)) + 
#   geom_point(size=1) +
#   xlab(paste0("PC1: ",percentVar[1],"% variance")) +
#   ylab(paste0("PC2: ",percentVar[2],"% variance")) +
#   facet_wrap(~group) +
#   coord_fixed()

## Get percent of variance explained
data_pcaDEGs <- plotPCA(rld_degs, intgroup = params$intgroup, returnData = TRUE, ntop=nrow(rld_degs))
percentVarDEGs <- round(100 * attr(data_pcaDEGs, "percentVar"))
```

This plot shows the principal components analysis limited to all DEGs. In this case, the first and second principal component explain `r percentVarDEGs[1]` and `r percentVarDEGs[2]` percent of the variance respectively.

## Top `r nBest` most variable genes only

```{r 'PCA_top'}

# Run this code only once for both the PCA and clustering analysis
rv = rowVars(assay(rld))
select = order(rv, decreasing = TRUE)[1:nBest]

rld_top <- rld[select,]

## Perform PCA analysis and make plot
plotPCA(rld_top, intgroup = params$intgroup, ntop=nrow(rld_top))

## Get percent of variance explained
data_pcaTop <- plotPCA(rld_top, intgroup = params$intgroup, returnData = TRUE, ntop=nrow(rld_top))
percentVarTop <- round(100 * attr(data_pcaTop, "percentVar"))
```

This plot shows the principal components analysis limited to all DEGs. In this case, the first and second principal component explain `r percentVarTop[1]` and `r percentVarTop[2]` percent of the variance respectively.

# Sample-to-sample distances {.tabset}

## All genes, before filtering

```{r 'sampleDist'}
## Obtain the sample euclidean distances
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists)
## Add names based on intgroup
rownames(sampleDistMatrix) <- apply(as.data.frame(colData(rld)[, params$design]), 1,
    paste, collapse = ' : ')
colnames(sampleDistMatrix) <- NULL

## Define colors to use for the heatmap
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

## Make the heatmap
pheatmap(sampleDistMatrix, clustering_distance_rows = sampleDists,
    clustering_distance_cols = sampleDists, color = colors)

```

This plot shows how samples are clustered based on their euclidean distance using the regularized log transformed count data. This figure gives an overview of how the samples are hierarchically clustered. It is a complementary figure to the PCA plot.

## DEGs only

```{r 'sampleDist_degs'}
## Limit to the top n genes
# rv = rowVars(assay(rld))
# select = order(rv, decreasing = TRUE)[1:nBest]
## Obtain the sample euclidean distances
# sampleDistsTop <- dist(t(assay(rld)[select,]))
sampleDistsDEGs <- dist(t(assay(rld_degs)))
# sampleDistMatrixTop <- as.matrix(sampleDistsTop)
sampleDistMatrixDEGs <- as.matrix(sampleDistsDEGs)

## Add names based on intgroup
rownames(sampleDistMatrixDEGs) <- apply(as.data.frame(colData(rld)[, params$design]), 1,
    paste, collapse = ' : ')
colnames(sampleDistMatrixDEGs) <- NULL

## Define colors to use for the heatmap
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

## Make the heatmap
pheatmap(sampleDistMatrixDEGs,
         clustering_distance_rows = sampleDistsDEGs,
         clustering_distance_cols = sampleDistsDEGs,
         color = colors)
```

This plot shows how samples are clustered based on their euclidean distance using the regularized log transformed count data of all DEGs. This figure gives an overview of how the samples are hierarchically clustered. It is a complementary figure to the PCA plot.

## Most variable genes only

```{r 'sampleDist_top'}
## Limit to the top n genes
## Using the select object from PCA code above...
## Obtain the sample euclidean distances
sampleDistsTop <- dist(t(assay(rld)[select,]))
sampleDistMatrixTop <- as.matrix(sampleDistsTop)

## Add names based on intgroup
rownames(sampleDistMatrixTop) <- apply(as.data.frame(colData(rld)[, params$intgroup]), 1,
    paste, collapse = ' : ')
colnames(sampleDistMatrixTop) <- NULL

## Define colors to use for the heatmap
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

## Make the heatmap
pheatmap(sampleDistMatrixTop,
         clustering_distance_rows = sampleDistsTop,
         clustering_distance_cols = sampleDistsTop,
         color = colors)
```

This plot shows how samples are clustered based on their euclidean distance using the regularized log transformed count data of the top `r nBest` most variable genes. This figure gives an overview of how the samples are hierarchically clustered. It is a complementary figure to the PCA plot.

# Heatmaps {.tabset}

## All DEGs

```{r 'heatmap_all_DEGs', collapse=TRUE, fig.height=10}

mat <- assay(rld)[row.names(assay(rld)) %in% significantResults$ensembl_gene_id,]
mat <- mat - rowMeans(mat)

# quantile_breaks <- function(xs, n = 10) {
#   breaks <- quantile(xs, probs = seq(0, 1, length.out = n))
#   breaks[!duplicated(breaks)]
# }
# 
# mat_breaks <- quantile_breaks(mat, n = 11)
# pheatmap(mat,
#          annotation_col=heatmap_df,
#          show_rownames = FALSE,
#          border_color = NA,
#          scale="row",
#          breaks = mat_breaks)

heatmap_df <- as.data.frame(colData(rld)[,c("dose","group","treatment")]) # Customize!
pheatmap(mat,
         annotation_col=heatmap_df,
         show_rownames = FALSE,
         border_color = NA,
         scale="row")
# color = inferno(10)

chems=unique(DESeqDesign$chemical)
# plot_list=list()
for (chem in chems){

samples_for_heatmap <- DESeqDesign[which(DESeqDesign$chemical %in% c(chem, "DMSO 0.1%")),]$original_names
mat_subset <- mat[,samples_for_heatmap]

genes_for_heatmap_subset <- row.names(mat_subset)
genes_for_heatmap_subset <- data.frame(ensembl_gene_id=row.names(mat_subset)) %>%
  dplyr::left_join(id_table,
                   by="ensembl_gene_id") %>%
  dplyr::distinct()
genes_for_heatmap_subset$external_gene_name[is.na(genes_for_heatmap_subset$external_gene_name)]  <- genes_for_heatmap_subset$ensembl_gene_id[is.na(genes_for_heatmap_subset$external_gene_name)]
genes_for_heatmap$external_gene_name[which(genes_for_heatmap$external_gene_name=="")]  <- genes_for_heatmap$ensembl_gene_id[which(genes_for_heatmap$external_gene_name=="")] 
row.names(genes_for_heatmap_subset) <- genes_for_heatmap_subset$ensembl_gene_id

# pheatmap(mat_subset,
#          #color = rev(brewer.pal(11,"RdBu")), # inferno(10),
#          annotation_col=dplyr::select(heatmap_df,-original_names),
#          labels_row=genes_for_heatmap_subset[,2],
#          border_color = NA,
#          scale = "row",
#          cutree_rows = 3,
#          cutree_cols = 4)

mat_subset_ordered <- mat_subset[,dplyr::arrange(heatmap_df[which(heatmap_df$original_names %in% samples_for_heatmap), ],dose)$original_names]

# No clustering on columns
pheatmap(mat_subset_ordered,
         #color = rev(brewer.pal(11,"RdBu")), # inferno(10),
         annotation_col=dplyr::select(heatmap_df,-original_names),
         cluster_cols = F,
         labels_row=genes_for_heatmap_subset[,2],
         border_color = NA,
         scale = "row",
         cutree_rows = 3,
         cutree_cols = 4)

# x=pheatmap(mat,
#            annotation_col=heatmap_df,
#            show_rownames = FALSE,
#            border_color = NA,
#            scale="row")
#   plot_list[[a]] = x[[4]]     ##to save each plot into a list. note the [[4]]
# }
# do.call(grid.arrange,plot_list)

}


```

## Top `r nHeatmapDEGs` differentially abundant genes

```{r 'heatmap_top_degs', fig.height=10, fig.width=10, collapse=TRUE}
mat_top <- assay(rld)[row.names(assay(rld)) %in% allResultsOrdered_logFC_filter[1:nHeatmapDEGs,]$ensembl_gene_id,]
mat_top <- mat_top - rowMeans(mat_top)

genes_for_heatmap <- row.names(mat_top)
genes_for_heatmap <- data.frame(ensembl_gene_id=row.names(mat_top)) %>%
  dplyr::left_join(id_table,
                   by="ensembl_gene_id") %>%
  dplyr::distinct()
genes_for_heatmap$external_gene_name[is.na(genes_for_heatmap$external_gene_name)]  <- genes_for_heatmap$ensembl_gene_id[is.na(genes_for_heatmap$external_gene_name)]
genes_for_heatmap$external_gene_name[which(genes_for_heatmap$external_gene_name=="")]  <- genes_for_heatmap$ensembl_gene_id[which(genes_for_heatmap$external_gene_name=="")] 
row.names(genes_for_heatmap) <- genes_for_heatmap$ensembl_gene_id

pheatmap(mat_top,
         annotation_col=heatmap_df,
         labels_row=genes_for_heatmap[,2],
         show_rownames = TRUE,
         border_color = NA,
         scale="row")
# color = inferno(10)

```

## Top `r nHeatmap` variable genes

```{r 'heatmap_top_n_genes', fig.height=10, fig.width=10, collapse=TRUE}

# sliderInput("nHeatmapShiny", label = "Bandwidth adjustment:",
#              min = 10, max = 1000, value = 100, step = 10)

# Interactive heatmap

#renderPlot({
rv = rowVars(assay(rld))
select = order(rv, decreasing = TRUE)[1:nHeatmap]
matRV <- assay(rld)[select,]
matRV <- matRV - rowMeans(matRV)
genes_for_heatmap <- row.names(matRV)
genes_for_heatmap <- data.frame(ensembl_gene_id=row.names(matRV)) %>%
  dplyr::left_join(id_table,
                   by="ensembl_gene_id") %>%
  dplyr::distinct()
genes_for_heatmap$external_gene_name[is.na(genes_for_heatmap$external_gene_name)]  <- genes_for_heatmap$ensembl_gene_id[is.na(genes_for_heatmap$external_gene_name)]  
genes_for_heatmap$external_gene_name[which(genes_for_heatmap$external_gene_name=="")]  <- genes_for_heatmap$ensembl_gene_id[which(genes_for_heatmap$external_gene_name=="")] 
row.names(genes_for_heatmap) <- genes_for_heatmap$ensembl_gene_id

pheatmap(matRV,
         #color = rev(brewer.pal(11,"RdBu")), # inferno(10),
         annotation_col=heatmap_df,
         labels_row=genes_for_heatmap[,2],
         border_color = NA,
         scale = "row",
         cutree_rows = 3,
         cutree_cols = 4)

#})
```


# MA plots

This section contains three groups of MA plots (see [Wikipedia](https://en.wikipedia.org/wiki/MA_plot)) that compare the mean of the normalized counts against the log fold change. Each of the groups has a tab for each contrast. The plots show one point per feature. The points are shown in red if the feature has an adjusted p-value less than the cutoff listed in each section, that is, the statistically significant features are shown in red.

## Filtered at `r metadata(resList[[1]])$alpha` {.tabset}

This first group of plots shows `alpha` = `r metadata(resList[[1]])$alpha`, which is the `alpha` value used to determine which resulting features were significant when running the function `DESeq2::results()`.  

```{r 'MAplotalpha', results='asis'}
## MA plot with alpha used in DESeq2::results()
for (i in 1:length(resList)) {
contrast = gsub(pattern = "log2.*Time\ ",
                replacement =  "",
                x = resList[[i]]@elementMetadata[[2]][2])
cat("###", contrast, " \n")
DESeq2::plotMA(resList[[i]], alpha = metadata(resList[[i]])$alpha, main = paste('MA plot with alpha =',
    metadata(resList[[i]])$alpha,',',contrast))
cat('\n\n')
}

```





## Filtered at `r metadata(resList[[1]])$alpha / 2` {.tabset}

This second group of MA plots uses `alpha` = `r metadata(resList[[1]])$alpha / 2` and can be used against the first MA plot to identify features which have adjusted p-values between `r metadata(resList[[1]])$alpha / 2` and `r metadata(resList[[1]])$alpha`.

```{r 'MAplotalphaHalf', results='asis'}
## MA plot with alpha = 1/2 of the alpha used in DESeq2::results()
for (i in 1:length(resList)) {
contrast = gsub(pattern = "log2.*Time\ ",
                replacement =  "",
                x = resList[[i]]@elementMetadata[[2]][2])
cat("###", contrast, " \n")
DESeq2::plotMA(resList[[i]], alpha = metadata(resList[[i]])$alpha / 2,
    main = paste('MA plot with alpha =', metadata(resList[[i]])$alpha / 2,',',contrast))
cat('\n\n')
}

```



## Top `r min(nBest, nrow(head(res.df, n = nBest)))` features {.tabset}

The third and final set of MA plots uses an `alpha` such that the top `r min(nBest, nrow(head(res.df, n = nBest)))` features are shown in the plot.

```{r 'MAplotalpha-nBest', results='asis'}
## MA plot with alpha corresponding to the one that gives the nBest features

for (i in 1:length(resList)) {
nBest.actual <- min(nBest, nrow(head(resList[[i]], n = nBest)))
nBest.alpha <- head( resList[[i]][order(resList[[i]]$pvalue),], n = nBest)$padj[nBest.actual]
contrast = gsub(pattern = "log2.*Time\ ",
                replacement =  "",
                x = resList[[i]]@elementMetadata[[2]][2])
cat("###", contrast, " \n")
DESeq2::plotMA(resList[[i]], alpha = nBest.alpha * 1.00000000000001,
    main = paste('MA plot for top', nBest.actual, 'features',',',contrast))
cat('\n\n')
}
```


# P-values {.tabset}

## Distribution of all p-values

```{r pvalueHistogram, collapse=TRUE}
## P-value histogram plot

ggplot(allResults, aes(x = pvalue)) +
    geom_histogram(alpha=.5, position='identity', bins = 50) +
    labs(title='Histogram of unadjusted p-values') +
    xlab('Unadjusted p-values') +
    facet_wrap( ~ contrast, ncol = 2)

```

This plot shows a histogram of the unadjusted p-values. It might be skewed right or left, or flat as shown in the [Wikipedia examples](https://en.wikipedia.org/wiki/Histogram#Examples). The shape depends on the percent of features that are differentially expressed. For further information on how to interpret a histogram of p-values check [David Robinson's post on this topic](http://varianceexplained.org/statistics/interpreting-pvalue-histogram/).

```{r pvalueSumm}
## P-value distribution summary
summary(allResults$pvalue)
```

This is the numerical summary of the distribution of the p-values.


```{r pvalueTable, results = 'asis'}
## Split features by different p-value cutoffs
pval_table <- lapply(c(1e-04, 0.001, 0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5,
    0.6, 0.7, 0.8, 0.9, 1), function(x) {
    data.frame('Cut' = x, 'Count' = sum(allResults$pvalue <= x, na.rm = TRUE))
})
pval_table <- do.call(rbind, pval_table)
kable(pval_table, format = 'markdown', align = c('c', 'c'))
```

This table shows the number of features with p-values less or equal than some commonly used cutoff values. 

## Distribution of adjusted p-values

```{r padjHistogram, collapse=TRUE}
## Adjusted p-values histogram plot
ggplot(allResults, aes(x = padj)) +
    geom_histogram(alpha=.5, position='identity', bins = 50) +
    labs(title=paste('Histogram of', elementMetadata(resList[[1]])$description[grep('adjusted', elementMetadata(resList[[1]])$description)])) +
    xlab('Adjusted p-values') +
    xlim(c(0, 1.0005)) +
  facet_wrap( ~ contrast, ncol = 2, scales="free")
```

This plot shows a histogram of the `r elementMetadata(resList[[1]])$description[grep('adjusted', elementMetadata(resList[[1]])$description)]`. It might be skewed right or left, or flat as shown in the [Wikipedia examples](https://en.wikipedia.org/wiki/Histogram#Examples). 

```{r padjSumm}
## Adjusted p-values distribution summary
summary(res.df$padj)
```

This is the numerical summary of the distribution of the `r elementMetadata(resList[[1]])$description[grep('adjusted', elementMetadata(resList[[1]])$description)]`.


```{r padjTable, results = 'asis'}
## Split features by different adjusted p-value cutoffs
padj_table <- lapply(c(1e-04, 0.001, 0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5,
    0.6, 0.7, 0.8, 0.9, 1), function(x) {
    data.frame('Cut' = x, 'Count' = sum(res.df$padj <= x, na.rm = TRUE))
})
padj_table <- do.call(rbind, padj_table)
kable(padj_table, format = 'markdown', align = c('c', 'c'))
```

This table shows the number of features with `r elementMetadata(resList[[1]])$description[grep('adjusted', elementMetadata(resList[[1]])$description)]` less or equal than some commonly used cutoff values. 


# Tables of top features

This table shows the significant DEGs (passing all filtering criteria) ordered by their absolute fold change. Use the search function to find your feature of interest or sort by one of the columns. You can limit to a single contrast if desired.

```{r 'topFeatures', results = 'asis'}
searchURL <- "http://www.ncbi.nlm.nih.gov/gene/?term="
## Add search url if appropriate
res.df.dt <- res.df
if(!is.null(searchURL)) {
    res.df.dt$ensembl_gene_id <- paste0('<a href="',
                             searchURL,
                             res.df.dt$ensembl_gene_id,
                             '" rel="noopener noreferrer" target="_blank">',
                             res.df.dt$ensembl_gene_id,
                             '<br/>',
                             res.df.dt$external_gene_name,
                             '</a>')
}

for(i in which(colnames(res.df.dt) %in% c('pvalue', 'padj'))) res.df.dt[, i] <- format(res.df.dt[, i], scientific = TRUE)
res.df.dt <- res.df.dt[,!names(res.df.dt) %in% c("description", "external_gene_name")]
DT::datatable(res.df.dt,
          options = list(pagingType='full_numbers',
                         pageLength=20,
                         scrollX='100%',
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'excel', 'pdf', 'print', 'colvis'),
                         columnDefs = list(list(visible=FALSE, targets=c(2,4,5)))),
          escape = FALSE,
          extensions = 'Buttons',
          rownames = FALSE,
          filter = "top",
          colnames = c('Ensembl' = 'ensembl_gene_id')) %>% 
  DT::formatRound(which(!colnames(res.df.dt) %in% c('pvalue', 'padj', 'Feature', 'contrast', 'description', 'ensembl_gene_id', 'external_gene_name' )), digits)

```


# Gene-level plots for top `r nBestFeatures` features

This section contains plots showing the normalized counts per sample for each group of interest. Only the best `r nBestFeatures` features are shown, ranked by their absolute fold change values. The Y axis is on the log10 scale and the feature name is shown in the title of each plot.


```{r 'plotCounts'}
plotCounts_gg <- function(i, dds, intgroup) {
    data <- plotCounts(dds,
                       gene=i,
                       intgroup=params$intgroup,
                       returnData = TRUE)
    ggplot(data, aes(x = data[,2], y = data[,1])) + 
      geom_point() + 
      ylab('Normalized count') +
      xlab('Group') + 
      ggtitle(paste0(i, " ", id_table$external_gene_name[id_table$ensembl_gene_id == i])) + 
      coord_trans(y = "log10") + 
      theme(axis.text.x = element_text(angle = 90, hjust = 1))
}

genesToPlot <- significantResults %>% arrange(-abs(log2FoldChange))

for(i in head(unique(genesToPlot$ensembl_gene_id), nBestFeatures)) {
    print(plotCounts_gg(i, dds = dds, intgroup = params$intgroup))
}

```

# Plots of genes of interest

This section shows genes of interest sorted by those with highest fold-change within each contrast.

```{r 'plot_genes_of_interest', fig.width=16, fig.height=12}

#numResults=20
numResults <- nBestFeatures

allResultsOrdered_logFC_filter %>%
  group_by(contrast) %>%
  top_n(numResults, wt=abs(log2FoldChange)) %>%
  ungroup() %>%
  mutate(contrast=as.factor(contrast),
         external_gene_name=reorder_within(external_gene_name,log2FoldChange, contrast)) %>%
  ggplot(aes(x=log2FoldChange,
             y=external_gene_name,
             color=contrast,
             size=-log(padj))) +
  geom_point(show.legend = TRUE) +
  facet_wrap(~contrast,
             scales="free_y",
             ncol=4,
             labeller = labeller(contrast = label_wrap_gen(10))) +
  scale_y_reordered()  +
  geom_vline(xintercept=0,
             linetype="dashed",
             color = "black",
             size=1) +
  ggtitle(paste0("Top ",
                 numResults,
                 " genes ranked by fold change (adjusted p-value <",
                 alpha,
                 "), grouped by treatment"))
```

# Volcano plot

This section shows a volcano plot for each contrast.  
Note that scales are set manually for this plot: therefore, there may be data points outside the range shown (see warnings).

```{r 'volcano-plot', fig.width=16, fig.height=12, warning=TRUE, collapse=TRUE}
ggplot(allResults, aes(x=log2FoldChange, y=-log10(padj))) +
  geom_point(size=0.1, alpha=0.5) +
  facet_wrap(~contrast, ncol=4) + # , scales="free"
  geom_vline(xintercept=c(-1.5,1.5), color="red", alpha=1.0)+ 
  geom_hline(yintercept=-log10(0.05), color="blue", alpha=1.0) +
  scale_x_continuous(name = "log2 Fold Change", limits = c(-5,5)) + # 
  scale_y_continuous(name = "-log10 adjusted p-value", limits = c(0,6)) # 
```

```{r 'bmdexpress_input', collapse=TRUE}

###########################################################################################
######## PRODUCE INPUT FOR BMDExpress2 ####################################################
###########################################################################################

# # Create input file...
#lognorm.read.counts <- as.data.frame(counts(dds, normalized=TRUE))
# rld normalized, size factor normalized, rounded to 4 significant figures
bmdexpress <- as.data.frame(assay(rld))
bmdexpress <- cbind(SampleID=row.names(bmdexpress), bmdexpress, stringsAsFactors=F)
bmdexpress <- rbind( Dose=c("#CLASS:DOSE",as.numeric(DESeqDesign$dose)), bmdexpress, stringsAsFactors=F)
write.table(bmdexpress, file = "bmdexpress_input.txt", quote = F, sep = "\t", row.names = F, col.names = T)

# chem_subset <- DESeqDesign %>% dplyr::filter(chemical %in% c("D-8","DMSO 0.1%")) %>% dplyr::select(original_names)
# bmdexpresstest <- bmdexpress %>% dplyr::select(chem_subset$original_names)
# bmdexpresstest <- cbind(SampleID=row.names(bmdexpresstest), bmdexpresstest, stringsAsFactors=F)
# bmdexpresstest <- rbind(Chemical=c("#CLASS:CHEMICAL", as.data.frame(DESeqDesign %>% 
#                                                                     dplyr::filter(chemical %in% c("D-8","DMSO 0.1%")))$chemical),
#                                     bmdexpresstest,
#                                     stringsAsFactors=F)
# bmdexpresstest <- rbind( Dose=c("#CLASS:DOSE", as.data.frame(DESeqDesign %>% 
#                                                            dplyr::filter(chemical %in% c("D-8","DMSO 0.1%")))$dose),
#                                 bmdexpresstest,
#                                 stringsAsFactors=F)
# write.table(bmdexpresstest, file = "bmdexpress_test_input.txt", quote = F, sep = "\t", row.names = F, col.names = T)



fastbmd <- as.data.frame(assay(dds))
fastbmd <- cbind(SampleID=row.names(fastbmd), fastbmd, stringsAsFactors=F)
fastbmd <- rbind( Chemical=c("#CLASS:CHEMICAL",as.character(DESeqDesign[DESeqDesign$original_names %in% colnames(fastbmd),]$chemical)),
                  fastbmd,
                  stringsAsFactors=F)
fastbmd <- rbind( Dose=c("#CLASS:DOSE",format(DESeqDesign[DESeqDesign$original_names %in% colnames(fastbmd),]$dose, scientific=F)),
                  fastbmd,
                  stringsAsFactors=F)
write.table(fastbmd, file = "fastbmd_input.txt", quote = F, sep = "\t", row.names = F, col.names = T)

```

# GO Enrichment Analysis {.tabset}

This section performs GO enrichment on **all DEGs passing filters**.

```{r cluster-profiler, warning=FALSE, message=FALSE, collapse=TRUE}
## Remember that dds had ENSEMBL ids for the genes
# ensemblNames <- gsub("\\..*", "", rownames(dds))

ensemblDEGs <- significantResults$ensembl_gene_id
head(ensemblDEGs)
DEGs <- dplyr::left_join(data.frame(ensembl_gene_id=ensemblDEGs), id_table_entrez, by="ensembl_gene_id")
head(DEGs)
entrezDEGs <- as.character(DEGs$entrezgene_id)
entrezDEGs <- entrezDEGs[!is.na(entrezDEGs)]

#### DEFINE INPUTS
myDEGs <- entrezDEGs
# background <- row.names(assay(dds))
background <- dplyr::left_join(data.frame(ensembl_gene_id=row.names(assay(dds))), id_table_entrez, by="ensembl_gene_id") %>%
  dplyr::filter(!is.na(entrezgene_id)) %>%
  dplyr::pull(entrezgene_id)
background <- as.character(background)

entrezDEGs <- entrezDEGs[!is.na(entrezDEGs)]

##### TO DO: Add multiple panels for each contrast.
##### Use "all" argument to only run each once..?

## Not all genes have a p-value
table(!is.na(resList[[1]]$padj))

KeyType <- "ENTREZID" # ENSEMBL? ACCNUM? GID? ENTREZID?
# head(keys(orgdb, keytype="ENTREZID"))

enrich_go_all <- enrichGO(gene = myDEGs,
                         universe = background, # All genes in dataset
                         OrgDb = orgdb,
                         keyType = KeyType,
                         ont = "all",
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.01,
                         qvalueCutoff = 0.05)

# clusterProfiler::dotplot(enrich_go_all, font.size=9, showCategory=10, split="ONTOLOGY")  +
#   theme(axis.text.y = element_text(angle = 0)) +
#   scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 50)) +
#   facet_wrap(~ONTOLOGY)

## Perform enrichment analysis for Biological Process (BP)
enrich_go_bp <- enrichGO(gene = myDEGs,
                         universe = background, # All genes in dataset
                         OrgDb = orgdb,
                         keyType = KeyType,
                         ont = "BP",
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.01,
                         qvalueCutoff = 0.05)

enrich_go_mf <- enrichGO(gene = myDEGs,
                         universe = background, # All genes in dataset
                         OrgDb = orgdb,
                         keyType = KeyType,
                         ont = "MF",
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.01,
                         qvalueCutoff = 0.05) 

enrich_go_cc <- enrichGO(gene = myDEGs,
                         universe = background, # All genes in dataset
                         OrgDb = orgdb,
                         keyType = KeyType,
                         ont = "CC",
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.01,
                         qvalueCutoff = 0.05)

```

## Biological processes

```{r plot_GO_analysis_bp, message=FALSE, warning=FALSE, fig.width=10, collapse=TRUE}
clusterProfiler::dotplot(enrich_go_bp, font.size=9, showCategory=20)  +
  theme(axis.text.y = element_text(angle = 0)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))
```

## Molecular Functions

```{r plot_GO_analysis_mf, message=FALSE, warning=FALSE, fig.width=10, collapse=TRUE}
clusterProfiler::dotplot(enrich_go_mf, font.size=9)  +
   theme(axis.text.y = element_text(angle = 0)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))
```

## Cellular Component

```{r plot_GO_analysis_cc, message=FALSE, warning=FALSE, fig.width=10, collapse=TRUE}
clusterProfiler::dotplot(enrich_go_cc, font.size=9)  +
   theme(axis.text.y = element_text(angle = 0)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))

```

# Pathway Analysis using WikiPathways

## All DEGs

```{r 'pathway_analysis', collapse=TRUE}

entrez_IDs <- as.character(id_table_entrez$entrezgene_id)
entrezDEGs <- dplyr::left_join(significantResults,
                               id_table_entrez,
                               by="ensembl_gene_id")
entrezDEGs <- as.vector(entrezDEGs$entrezgene_id)

mouseWiki <- rWikiPathways::downloadPathwayArchive(organism=species_sci, format = "gmt")
wp2gene <- clusterProfiler::read.gmt(mouseWiki)
wp2gene <- wp2gene %>% tidyr::separate(ont, c("name","version","wpid","org"), "%")
wpid2gene <- wp2gene %>% dplyr::select(wpid,gene) #TERM2GENE
wpid2name <- wp2gene %>% dplyr::select(wpid,name) #TERM2NAME
wpid2gene
wpid2name

DEG_pathways <- clusterProfiler::enricher(
        entrezDEGs,
        universe = entrez_IDs,
        pAdjustMethod = "fdr",
        pvalueCutoff = 0.05, #p.adjust cutoff
        TERM2GENE = wpid2gene,
        TERM2NAME = wpid2name)
DEG_pathways <- DOSE::setReadable(DEG_pathways, orgdb, keyType = "ENTREZID")

clusterProfiler::dotplot(DEG_pathways, showCategory = 20, font.size=9)  +
  theme(axis.text.y = element_text(angle = 0)) +
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))
```

## By contrast {.tabset}

```{r 'pathway_analysis_by_contrast_make_plots', collapse=TRUE}
plotList <- list()
for (i in 1:length(levels(significantResults$contrast))) {
  entrezDEGs <- dplyr::left_join(significantResults[significantResults$contrast==levels(significantResults$contrast)[i],],
                                 id_table_entrez,
                                 by="ensembl_gene_id")
  entrezDEGs <- entrezDEGs$entrezgene_id
  DEG_pathways <- clusterProfiler::enricher(
          entrezDEGs,
          universe = entrez_IDs,
          pAdjustMethod = "fdr",
          pvalueCutoff = 0.05, #p.adjust cutoff
          TERM2GENE = wpid2gene,
          TERM2NAME = wpid2name)
  DEG_pathways <- DOSE::setReadable(DEG_pathways, orgdb, keyType = "ENTREZID")
  plotList[[i]] <- clusterProfiler::dotplot(DEG_pathways, showCategory = 20, font.size=9)  +
     theme(axis.text.y = element_text(angle = 0)) +
    scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 30))
}
```


```{r 'pathway_analysis_by_contrast_print_plots', results='asis'}
for (i in 1:length(levels(significantResults$contrast))) {
  cat("###", levels(significantResults$contrast)[i], " \n")
  print(plotList[[i]])
  cat('\n\n')
}

```

# Session Info

Date the report was generated.

```{r reproducibility1, echo=FALSE}
## Date the report was generated
Sys.time()
```

Wallclock time spent generating the report.

```{r reproducibility2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits=3)
```

`R` session information.

```{r reproducibility3, echo=FALSE}
## Session info
options(width = 120)
session_info()
```

Pandoc version used: `r rmarkdown::pandoc_version()`.

```{r 'save_final', show=FALSE}
# Save complete workspace
setwd(paths$DEG_output)
save.image(file = "Complete_analysis.RData")
# Add a flag to the start of the script with if statements in all code chunks to check if the flag is set.
# If flag is TRUE, run analysis; if flag is FALSE, SKIP analysis and continue here (just to modify plotting output).
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>